package uni.bielefeld.cmg.reflexiv.pipeline;


import org.apache.commons.lang.StringUtils;
import org.apache.hadoop.io.compress.GzipCodec;
import org.apache.spark.SparkConf;
import org.apache.spark.SparkContext;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.*;
import org.apache.spark.broadcast.Broadcast;
import org.apache.spark.sql.*;
import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;
import org.apache.spark.sql.catalyst.encoders.RowEncoder;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructType;
import org.apache.spark.storage.StorageLevel;
import scala.Tuple2;
import scala.collection.JavaConverters;
import scala.collection.Seq;
import uni.bielefeld.cmg.reflexiv.util.DefaultParam;
import uni.bielefeld.cmg.reflexiv.util.InfoDumper;

import java.io.Serializable;
import java.util.*;

import static org.apache.spark.sql.functions.col;
import static org.apache.spark.sql.functions.max;


/**
 * Created by rhinempi on 22.07.2017.
 * <p>
 * Reflexiv
 * <p>
 * Copyright (c) 2017.
 * Liren Huang     <huanglr at cebitec.uni-bielefeld.de>
 * <p>
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * Returns an object for running the Reflexiv main pipeline.
 *
 * @author Liren Huang
 * @version %I%, %G%
 * @see
 */
public class ReflexivDSDynamicKmer64 implements Serializable {
    private long time;
    private DefaultParam param;

    private InfoDumper info = new InfoDumper();

    /**
     *
     */
    private void clockStart() {
        time = System.currentTimeMillis();
    }

    /**
     *
     * @return
     */
    private long clockCut() {
        long tmp = time;
        time = System.currentTimeMillis();
        return time - tmp;
    }

    /**wc
     *
     * @return
     */
    private SparkConf setSparkConfiguration() {
        SparkConf conf = new SparkConf().setAppName("Reflexiv");
        conf.set("spark.serializer", "org.apache.spark.serializer.KryoSerializer");
        conf.set("spark.kryo.registrator", "uni.bielefeld.cmg.reflexiv.serializer.SparkKryoRegistrator");

        return conf;
    }

    private SparkSession setSparkSessionConfiguration(int shufflePartitions) {
        SparkSession spark = SparkSession
                .builder()
                .appName("Reflexiv")
                .config("spark.kryo.registrator", "uni.bielefeld.cmg.reflexiv.serializer.SparkKryoRegistrator")
                .config("spark.serializer", "org.apache.spark.serializer.KryoSerializer")
                .config("spark.cleaner.referenceTracking.cleanCheckpoints", true)
                .config("spark.checkpoint.compress",true)
                .config("spark.sql.shuffle.partitions", String.valueOf(shufflePartitions))
                .config("spark.sql.files.maxPartitionBytes", "12000000")
                .config("spark.sql.adaptive.advisoryPartitionSizeInBytes","12mb")
                .config("spark.driver.maxResultSize","1000g")
                .config("spark.memory.fraction","0.8")
                .config("spark.network.timeout","60000s")
                .config("spark.executor.heartbeatInterval","20000s")
                .getOrCreate();

        return spark;
    }

    private Hashtable<List<Long>, Integer> SubKmerProbRowToHash(List<Row> s){
        Hashtable<List<Long>, Integer> ProbHash = new Hashtable<List<Long>, Integer>();
        for (int i =0; i<s.size();i++){
            List<Long> Key = new ArrayList<Long>();
            for (int j=0; j<s.get(i).getSeq(0).size(); j++){
                Key.add((Long) s.get(i).getSeq(0).apply(j));
            }
            Integer Value = s.get(i).getInt(1);
            ProbHash.put(Key, Value);
        }

        return ProbHash;
    }

    /**
     *
     */
    public void assembly() {
        SparkSession spark = setSparkSessionConfiguration(param.shufflePartition);

        info.readMessage("Initiating Spark context ...");
        info.screenDump();
        info.readMessage("Start Spark framework");
        info.screenDump();

        Dataset<String> FastqDS;
        Dataset<Row> KmerBinaryDS;

        Dataset<Row> KmerBinaryCountLongDS;
        Dataset<Row> KmerBinaryCountDS;

        StructType kmerCountTupleStruct = new StructType();
        kmerCountTupleStruct = kmerCountTupleStruct.add("kmerBlocks", DataTypes.createArrayType(DataTypes.LongType), false);
        kmerCountTupleStruct = kmerCountTupleStruct.add("count", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> KmerBinaryCountEncoder = RowEncoder.apply(kmerCountTupleStruct);
/*
        StructType kmerBinaryStruct = new StructType();
        kmerBinaryStruct = kmerBinaryStruct.add("kmerBlocks", DataTypes.createArrayType(DataTypes.LongType), false);
        kmerBinaryStruct = kmerBinaryStruct.add("count", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> kmerBinaryEncoder = RowEncoder.apply(kmerBinaryStruct);
*/
        Dataset<Row> ReflexivSubKmerDS;
        StructType ReflexivKmerStruct = new StructType();
        ReflexivKmerStruct = ReflexivKmerStruct.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("extension", DataTypes.LongType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("left", DataTypes.IntegerType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivSubKmerEncoder = RowEncoder.apply(ReflexivKmerStruct);

        Dataset<Row> ReflexivSubKmerStringDS;
        StructType ReflexivKmerStringStruct = new StructType();
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("k-1", DataTypes.StringType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("extension", DataTypes.StringType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("left", DataTypes.IntegerType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivKmerStringEncoder = RowEncoder.apply(ReflexivKmerStringStruct);

        Dataset<Row> ReflexivLongSubKmerDS;
        StructType ReflexivLongKmerStruct = new StructType();
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("extension", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("left", DataTypes.IntegerType, false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivLongKmerEncoder = RowEncoder.apply(ReflexivLongKmerStruct);

        Dataset<Row> ReflexivLongSubKmerStringDS;
        StructType ReflexivLongKmerStringStruct = new StructType();
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("k-1", DataTypes.StringType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("extension", DataTypes.StringType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("left", DataTypes.IntegerType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivLongKmerStringEncoder = RowEncoder.apply(ReflexivLongKmerStringStruct);

        Dataset<Row> ContigRows;
        StructType ContigLongKmerStringStruct = new StructType();
        ContigLongKmerStringStruct = ContigLongKmerStringStruct.add("ID", DataTypes.StringType, false);
        ContigLongKmerStringStruct = ContigLongKmerStringStruct.add("contig", DataTypes.StringType, false);
        ExpressionEncoder<Row> ContigStringEncoder = RowEncoder.apply(ContigLongKmerStringStruct);

        JavaRDD<Row> ContigRowsRDD;
        JavaPairRDD<Row, Long> ContigsRDDIndex;
        JavaRDD<String> ContigRDD;

        FastqDS = spark.read().text(param.inputFqPath).as(Encoders.STRING());

        DSFastqFilterWithQual DSFastqFilter = new DSFastqFilterWithQual();
        FastqDS = FastqDS.map(DSFastqFilter, Encoders.STRING());

        DSFastqUnitFilter FilterDSUnit = new DSFastqUnitFilter();

        FastqDS = FastqDS.filter(FilterDSUnit);

        if (param.partitions > 0) {
            FastqDS = FastqDS.repartition(param.partitions);
        }
        if (param.cache) {
            FastqDS.cache();
        }

        ReverseComplementKmerBinaryExtractionFromDataset64 DSExtractRCKmerBinaryFromFastq = new ReverseComplementKmerBinaryExtractionFromDataset64();
        KmerBinaryDS = FastqDS.mapPartitions(DSExtractRCKmerBinaryFromFastq, KmerBinaryCountEncoder);

        KmerBinaryCountLongDS = KmerBinaryDS.groupBy("kmerBlocks")
                .count()
                .toDF("kmerBlocks", "count");

        KmerBinaryCountLongDS = KmerBinaryCountLongDS.filter(col("count")
                .geq(param.minKmerCoverage)
                .and(col("count")
                        .leq(param.maxKmerCoverage)
                )
        );

        /**
         * Extract reverse complementary kmer
         */
        DSKmerReverseComplement DSRCKmer = new DSKmerReverseComplement();
        KmerBinaryCountDS = KmerBinaryCountLongDS.mapPartitions(DSRCKmer, KmerBinaryCountEncoder);

        /**
         * Extract forward sub kmer
         */

        DSForwardFixingSubKmerExtraction DSextractForwardSubKmer = new DSForwardFixingSubKmerExtraction();
        ReflexivSubKmerDS = KmerBinaryCountDS.mapPartitions(DSextractForwardSubKmer, ReflexivSubKmerEncoder);

        if (param.bubble == true) {
            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
            if (param.minErrorCoverage == 0) {
                DSFilterForkSubKmer DShighCoverageSelector = new DSFilterForkSubKmer();
                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageSelector, ReflexivSubKmerEncoder);
            } else {
                DSFilterForkSubKmerWithErrorCorrection DShighCoverageErrorRemovalSelector = new DSFilterForkSubKmerWithErrorCorrection();
                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageErrorRemovalSelector, ReflexivSubKmerEncoder);
            }

            DSReflectedFixingSubKmerExtractionFromForward DSreflectionExtractor = new DSReflectedFixingSubKmerExtractionFromForward();
            ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSreflectionExtractor, ReflexivSubKmerEncoder);

            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
            if (param.minErrorCoverage == 0) {
                DSFilterForkReflectedSubKmer DShighCoverageReflectedSelector = new DSFilterForkReflectedSubKmer();
                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageReflectedSelector, ReflexivSubKmerEncoder);
            } else {
                DSFilterForkReflectedSubKmerWithErrorCorrection DShighCoverageReflectedErrorRemovalSelector = new DSFilterForkReflectedSubKmerWithErrorCorrection();
                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageReflectedErrorRemovalSelector, ReflexivSubKmerEncoder);
            }

        }

        /**
         *
         */
        DSkmerRandomReflection DSrandomizeSubKmer = new DSkmerRandomReflection();
        ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSrandomizeSubKmer, ReflexivSubKmerEncoder);

        ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");

        DSBinaryReflexivKmerToString StringOutputDS = new DSBinaryReflexivKmerToString();

        DSExtendReflexivKmer DSKmerExtention = new DSExtendReflexivKmer();
        ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtention, ReflexivSubKmerEncoder);


        int iterations = 0;
        for (int i = 1; i < 4; i++) {
            iterations++;
            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
            ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtention, ReflexivSubKmerEncoder);
        }

        ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
        //       ReflexivSubKmerDS.cache();

        iterations++;

        /**
         * Extract Long sub kmer
         */


        DSExtendReflexivKmerToArrayFirstTime DSKmerExtentionToArrayFirst = new DSExtendReflexivKmerToArrayFirstTime();
        ReflexivLongSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtentionToArrayFirst, ReflexivLongKmerEncoder);
        ReflexivLongSubKmerDS.cache();

        DSExtendReflexivKmerToArrayLoop DSKmerExtenstionArrayToArray = new DSExtendReflexivKmerToArrayLoop();

        DSBinaryReflexivKmerArrayToString DSArrayStringOutput = new DSBinaryReflexivKmerArrayToString();

        //      ReflexivSubKmerDS.unpersist();
        int partitionNumber = ReflexivLongSubKmerDS.toJavaRDD().getNumPartitions();
        long contigNumber = 0;
        while (iterations <= param.maximumIteration) {
            iterations++;
            if (iterations >= param.minimumIteration) {
                if (iterations % 3 == 0) {

                    /**
                     *  problem ------------------------------------------v
                     */
                    ReflexivLongSubKmerDS.cache();
                    long currentContigNumber = ReflexivLongSubKmerDS.count();
                    if (contigNumber == currentContigNumber) {
                        break;
                    } else {
                        contigNumber = currentContigNumber;
                    }

                    if (partitionNumber >= 16) {
                        if (currentContigNumber / partitionNumber <= 20) {
                            partitionNumber = partitionNumber / 4 + 1;
                            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.coalesce(partitionNumber);
                        }
                    }
                }
            }

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongKmerEncoder);

        }

        /**
         *
         */
        ReflexivLongSubKmerStringDS = ReflexivLongSubKmerDS.mapPartitions(DSArrayStringOutput, ReflexivLongKmerStringEncoder);

        /**
         *
         */

        DSKmerToContig contigformaterDS = new DSKmerToContig();
        ContigRows = ReflexivLongSubKmerStringDS.mapPartitions(contigformaterDS, ContigStringEncoder);


        /**
         *
         */
        ContigRowsRDD = ContigRows.toJavaRDD();

        ContigRowsRDD.cache();

        ContigsRDDIndex = ContigRowsRDD.zipWithIndex();

        TagRowContigID DSIdLabeling = new TagRowContigID();
        ContigRDD = ContigsRDDIndex.flatMap(DSIdLabeling);

        ContigRDD.saveAsTextFile(param.outputPath);

        spark.stop();
    }

    /**
     *
     */
    public void assemblyFromKmer() {
        SparkSession spark = setSparkSessionConfiguration(param.shufflePartition);
        SparkContext sc = spark.sparkContext();
        JavaSparkContext jsc = JavaSparkContext.fromSparkContext(sc);

        info.readMessage("Initiating Spark context ...");
        info.screenDump();
        info.readMessage("Start Spark framework");
        info.screenDump();

        sc.setCheckpointDir("/tmp/checkpoints");
        String checkpointDir= sc.getCheckpointDir().get();

        Dataset<Row> KmerCountDS;
        Dataset<String> FastqDS;

        Dataset<Row> KmerBinaryCountDS;
        Dataset<Row> FixingLongKmerDS;
        StructType kmerCountTupleStruct = new StructType();
        kmerCountTupleStruct = kmerCountTupleStruct.add("kmer", DataTypes.createArrayType(DataTypes.LongType), false);
        kmerCountTupleStruct = kmerCountTupleStruct.add("count", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> KmerBinaryCountEncoder = RowEncoder.apply(kmerCountTupleStruct);

        Dataset<Row> ReflexivLongFullKmerDS;
        StructType kmerBinaryCountTupleLongStruct = new StructType();
        kmerBinaryCountTupleLongStruct = kmerBinaryCountTupleLongStruct.add("kmer", DataTypes.createArrayType(DataTypes.LongType), false);
        kmerBinaryCountTupleLongStruct = kmerBinaryCountTupleLongStruct.add("count", DataTypes.LongType, false);
        ExpressionEncoder<Row> KmerBinaryCountLongEncoder = RowEncoder.apply(kmerBinaryCountTupleLongStruct);

        Dataset<Row> FixingKmerDS;
        StructType kmerFixingStruct = new StructType();
        kmerFixingStruct = kmerFixingStruct.add("kmer", DataTypes.LongType, false);
        kmerFixingStruct = kmerFixingStruct.add("count", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> kmerFixingEncoder = RowEncoder.apply(kmerFixingStruct);

        Dataset<Row> FixingKmerDSString;
        StructType kmerCountTupleStringStruct = new StructType();
        kmerCountTupleStringStruct = kmerCountTupleStringStruct.add("kmer", DataTypes.StringType, false);
        kmerCountTupleStringStruct = kmerCountTupleStringStruct.add("count", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> KmerBinaryCountStringEncoder = RowEncoder.apply(kmerCountTupleStringStruct);

        StructType kmerCountTupleStringLongStruct = new StructType();
        kmerCountTupleStringLongStruct = kmerCountTupleStringLongStruct.add("kmer", DataTypes.StringType, false);
        kmerCountTupleStringLongStruct = kmerCountTupleStringLongStruct.add("count", DataTypes.LongType, false);
        ExpressionEncoder<Row> KmerBinaryCountStringLongEncoder = RowEncoder.apply(kmerCountTupleStringLongStruct);

        StructType ReflexivFixingKmerStruct = new StructType();
        ReflexivFixingKmerStruct= ReflexivFixingKmerStruct.add("k-1", DataTypes.LongType, false);
        ReflexivFixingKmerStruct= ReflexivFixingKmerStruct.add("attribute", DataTypes.LongType, false);
        ReflexivFixingKmerStruct= ReflexivFixingKmerStruct.add("extension", DataTypes.createArrayType(DataTypes.LongType), false);
        ExpressionEncoder<Row> ReflexivFixingKmerEndocer = RowEncoder.apply(ReflexivFixingKmerStruct);

        Dataset<Row> ReflexivSubKmerDS;
        Dataset<Row> ReflexivSubKmerDS2;
        StructType ReflexivKmerStruct = new StructType();
        ReflexivKmerStruct = ReflexivKmerStruct.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("extension", DataTypes.LongType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("left", DataTypes.IntegerType, false);
        ReflexivKmerStruct = ReflexivKmerStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivSubKmerEncoder = RowEncoder.apply(ReflexivKmerStruct);

        Dataset<Row> ReflexivSubKmerDSCompressed;
        StructType ReflexivKmerStructCompressed = new StructType();
        ReflexivKmerStructCompressed= ReflexivKmerStructCompressed.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivKmerStructCompressed = ReflexivKmerStructCompressed.add("attribute", DataTypes.LongType, false);
        ReflexivKmerStructCompressed = ReflexivKmerStructCompressed.add("extension", DataTypes.LongType, false);
        ExpressionEncoder<Row> ReflexivSubKmerEncoderCompressed = RowEncoder.apply(ReflexivKmerStructCompressed);

        Dataset<Row> ReflexivLongSubKmerDSCompressed;
        StructType ReflexivLongKmerStructCompressed = new StructType();
        ReflexivLongKmerStructCompressed= ReflexivLongKmerStructCompressed.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivLongKmerStructCompressed= ReflexivLongKmerStructCompressed.add("attribute", DataTypes.LongType, false);
        ReflexivLongKmerStructCompressed= ReflexivLongKmerStructCompressed.add("extension", DataTypes.createArrayType(DataTypes.LongType), false);
        ExpressionEncoder<Row> ReflexivLongSubKmerEncoderCompressed = RowEncoder.apply(ReflexivLongKmerStructCompressed);

        Dataset<Row> ReflexivSubKmerStringDS;
        StructType ReflexivKmerStringStruct = new StructType();
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("k-1", DataTypes.StringType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("extension", DataTypes.StringType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("left", DataTypes.IntegerType, false);
        ReflexivKmerStringStruct = ReflexivKmerStringStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivKmerStringEncoder = RowEncoder.apply(ReflexivKmerStringStruct);

        Dataset<Row> ReflexivLongSubKmerDS;
        Dataset<Row> ReflexivLongSubKmerDS2;
        Dataset<Row> ReflexivLongFragmentDS;
        Dataset<Row> ExtendableReflexivKmer = null;
        Dataset<Row> ExtendableReflexivKmerPairs = null;
        Dataset<Row> UnExtendableReflexivKmer = null;
        Dataset<Row> UnExtendableReflexivKmerPairs = null;
        StructType ReflexivLongKmerStruct = new StructType();
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("k-1", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("reflection", DataTypes.IntegerType, false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("extension", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("left", DataTypes.IntegerType, false);
        ReflexivLongKmerStruct = ReflexivLongKmerStruct.add("right", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivLongKmerEncoder = RowEncoder.apply(ReflexivLongKmerStruct);

        Dataset<Row> ReflexivLongSubKmerStringDS;
        StructType ReflexivLongKmerStringStruct = new StructType();
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("k-1", DataTypes.StringType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("attribute", DataTypes.LongType, false);
        ReflexivLongKmerStringStruct = ReflexivLongKmerStringStruct.add("extension", DataTypes.StringType, false);
        ExpressionEncoder<Row> ReflexivLongKmerStringEncoder = RowEncoder.apply(ReflexivLongKmerStringStruct);

        Dataset<Row> ContigProbRows;
        StructType ReflexivSubKmerProbStruct = new StructType();
        ReflexivSubKmerProbStruct = ReflexivSubKmerProbStruct.add("subkmerBinary", DataTypes.createArrayType(DataTypes.LongType), false);
        ReflexivSubKmerProbStruct = ReflexivSubKmerProbStruct.add("marker", DataTypes.IntegerType, false);
        ExpressionEncoder<Row> ReflexivSubKmerProbEncoder = RowEncoder.apply(ReflexivSubKmerProbStruct);

        Dataset<Row> markerKmer;
        StructType ReflexivKmerMarkerStruct = new StructType();
        ReflexivKmerMarkerStruct = ReflexivKmerMarkerStruct.add("kmerBinary", DataTypes.LongType, false);
        ReflexivKmerMarkerStruct = ReflexivKmerMarkerStruct.add("attribute", DataTypes.LongType, false);
        ExpressionEncoder<Row> ReflexivKmerMarkerEncoder = RowEncoder.apply(ReflexivKmerMarkerStruct);


        Dataset<Row> ContigRows;
        Dataset<Row> markerKmerString;
        StructType ContigLongKmerStringStruct = new StructType();
        ContigLongKmerStringStruct = ContigLongKmerStringStruct.add("ID", DataTypes.StringType, false);
        ContigLongKmerStringStruct = ContigLongKmerStringStruct.add("contig", DataTypes.StringType, false);
        ExpressionEncoder<Row> ContigStringEncoder = RowEncoder.apply(ContigLongKmerStringStruct);

        StructType ContigLongKmerStringStruct2 = new StructType();
        ContigLongKmerStringStruct2 = ContigLongKmerStringStruct2.add("ID", DataTypes.StringType, false);
        ContigLongKmerStringStruct2 = ContigLongKmerStringStruct2.add("contig", DataTypes.StringType, false);
        ContigLongKmerStringStruct2 = ContigLongKmerStringStruct2.add("contig2", DataTypes.StringType, false);
        ContigLongKmerStringStruct2 = ContigLongKmerStringStruct2.add("contig3", DataTypes.StringType, false);
        ContigLongKmerStringStruct2 = ContigLongKmerStringStruct2.add("contig4", DataTypes.StringType, false);
        ExpressionEncoder<Row> ContigString2Encoder = RowEncoder.apply(ContigLongKmerStringStruct2);

        StructType ContigLongKmerStringStruct3 = new StructType();
        ContigLongKmerStringStruct3 = ContigLongKmerStringStruct3.add("ID", DataTypes.StringType, false);
        ContigLongKmerStringStruct3 = ContigLongKmerStringStruct3.add("contig", DataTypes.StringType, false);
        ContigLongKmerStringStruct3 = ContigLongKmerStringStruct3.add("contig2", DataTypes.StringType, false);

        ExpressionEncoder<Row> ContigString3Encoder = RowEncoder.apply(ContigLongKmerStringStruct3);


        Dataset<Tuple2<Row, Long>> markerTuple;
        Dataset<Row> markerTupleRow;
        Dataset<Row> FixingFullKmer;
        Dataset<Row> MarkerShorterKmerID;
        Dataset<Row> MarkerIDCount;
        Dataset<Row> markerShortIDRow;
        StructType markerTupleStruct = new StructType();
        markerTupleStruct = markerTupleStruct.add("kmer", DataTypes.createArrayType(DataTypes.LongType), false);

        ExpressionEncoder<Row> markerTupleEncoder = RowEncoder.apply(markerTupleStruct);

        JavaRDD<Row> ContigRowsRDD;
        JavaPairRDD<Row, Long> ContigsRDDIndex;
        JavaPairRDD<String, Long> ContigsDSIndex;
        JavaRDD<String> ContigRDD;
        Dataset<String> ContigDS;



        /**
         * loading Kmer counts
         */
        KmerCountDS = spark.read().csv(param.inputKmerPath);

        if (param.partitions > 0) {
            KmerCountDS = KmerCountDS.repartition(param.partitions);
        }

        /**
         * Transforming kmer string to binary kmer
         */
//        DynamicKmerBinarizer DSBinarizer = new DynamicKmerBinarizer();
//        KmerBinaryCountDS = KmerCountDS.mapPartitions(DSBinarizer, KmerBinaryCountEncoder);

        /**
         * Filter kmer with lower coverage
         */
//        KmerBinaryCountDS = KmerBinaryCountDS.filter(col("count")
//                .geq(param.minKmerCoverage)
//                .and(col("count"
//                        .leq(param.maxKmerCoverage)
//                )
//        );


//        if (param.cache) {
//            KmerBinaryCountDS.cache();
//       }

        /**
         * Extract reverse complementary kmer
         */
//        DSKmerReverseComplement DSRCKmer = new DSKmerReverseComplement();
//        KmerBinaryCountDS = KmerBinaryCountDS.mapPartitions(DSRCKmer, KmerBinaryCountEncoder);

//        KmerBinaryCountDS.show();

        /**
         * Extract forward sub kmer
         */


//        DSForwardSubKmerExtraction DSextractForwardSubKmer = new DSForwardSubKmerExtraction();
//        ReflexivSubKmerDS = KmerBinaryCountDS.mapPartitions(DSextractForwardSubKmer, ReflexivSubKmerEncoderCompressed);

//        ReflexivSubKmerDS.show();

//        if (param.bubble == true) {
//            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
//            if (param.minErrorCoverage == 0) {
//                DSFilterForkSubKmer DShighCoverageSelector = new DSFilterForkSubKmer();
//                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageSelector, ReflexivSubKmerEncoder);
 //           } else {
//                DSFilterForkSubKmerWithErrorCorrection DShighCoverageErrorRemovalSelector = new DSFilterForkSubKmerWithErrorCorrection();
//                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageErrorRemovalSelector, ReflexivSubKmerEncoderCompressed);
//            }

//            DSReflectedSubKmerExtractionFromForward DSreflectionExtractor = new DSReflectedSubKmerExtractionFromForward();
//            ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSreflectionExtractor, ReflexivSubKmerEncoder);

//            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
//            if (param.minErrorCoverage == 0) {
//                DSFilterForkReflectedSubKmer DShighCoverageReflectedSelector = new DSFilterForkReflectedSubKmer();
//                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageReflectedSelector, ReflexivSubKmerEncoder);
//            } else {
//                DSFilterForkReflectedSubKmerWithErrorCorrection DShighCoverageReflectedErrorRemovalSelector = new DSFilterForkReflectedSubKmerWithErrorCorrection();
//                ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DShighCoverageReflectedErrorRemovalSelector, ReflexivSubKmerEncoderCompressed);
//            }
//        }

        /**
         * Binarize Reduced Kmer Strings to sub kmers
         */

        DynamicKmerBinarizerFromReducedToSubKmer ReducedKmerToSubKmer= new DynamicKmerBinarizerFromReducedToSubKmer();
        ReflexivSubKmerDS = KmerCountDS.mapPartitions(ReducedKmerToSubKmer, ReflexivSubKmerEncoderCompressed);
        // KmerCountDS.unpersist();

        DSkmerRandomReflection DSrandomizeSubKmer = new DSkmerRandomReflection();
        ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSrandomizeSubKmer, ReflexivSubKmerEncoderCompressed);

        ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");

        // DSBinaryReflexivKmerToString StringOutputDS = new DSBinaryReflexivKmerToString();
        //   Dataset<Row>  ReflexivSubKmerStringDS= ReflexivSubKmerDS.mapPartitions(StringOutputDS, reflexivKmerStringEncoder);
        //ReflexivSubKmerStringDS.toJavaRDD().saveAsTextFile(param.outputPath + 1);

        DSExtendReflexivKmer DSKmerExtention = new DSExtendReflexivKmer();
        ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtention, ReflexivSubKmerEncoderCompressed);


        int iterations = 0;
        for (int i = 1; i < 4; i++) { // first four (here three, plus one before) iterations only use long as extend parts as the first three extension can reach maximum 16nt, that can be stored in a long, to reduce memory consumption
            iterations++;
            ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
            ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtention, ReflexivSubKmerEncoderCompressed);
        }
/*
        ReflexivSubKmerDS.checkpoint();

        iterations++;
        ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
        ReflexivSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtention, ReflexivSubKmerEncoderCompressed);
*/

        ReflexivSubKmerDS = ReflexivSubKmerDS.sort("k-1");
        //      ReflexivSubKmerDS.cache();

        iterations++;

        //ReflexivSubKmerStringDS= ReflexivSubKmerDS.mapPartitions(StringOutputDS, ReflexivKmerStringEncoder);
        // ReflexivSubKmerStringDS.toJavaRDD().saveAsTextFile(param.outputPath + iterations);
        //ReflexivSubKmerStringDS.write().format("csv").save(param.outputPath + iterations);

        /**
         * Extract Long sub kmer
         */

        DSExtendReflexivKmerToArrayFirstTime DSKmerExtentionToArrayFirst = new DSExtendReflexivKmerToArrayFirstTime();
        ReflexivLongSubKmerDS = ReflexivSubKmerDS.mapPartitions(DSKmerExtentionToArrayFirst, ReflexivLongSubKmerEncoderCompressed);

  //      ReflexivLongSubKmerDS.checkpoint();

   //     ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

        DSExtendReflexivKmerToArrayLoop DSKmerExtenstionArrayToArray = new DSExtendReflexivKmerToArrayLoop();

//        DSBinaryReflexivKmerArrayToString DSArrayStringOutput = new DSBinaryReflexivKmerArrayToString();

        // ReflexivSubKmerDS.unpersist();
   //     ReflexivLongSubKmerDS.cache();

 //       DSReflexivAndForwardKmer DSReflexivDouble = new DSReflexivAndForwardKmer();

   //     DSFilterExtendableKmerPairs DSReflexivExtendablePairs = new DSFilterExtendableKmerPairs();
   //     DSFilterStillExtendableKmerFromPairs DSReflexivExtendable = new DSFilterStillExtendableKmerFromPairs();
   //     DSFilterUnExtendableKmer DSReflexivUnExtendable = new DSFilterUnExtendableKmer();


        //int partitionNumber = ReflexivLongSubKmerDS.toJavaRDD().getNumPartitions();
        long contigNumber = 0;
        while (iterations <= param.maximumIteration) {
            iterations++;
/*
            if (iterations == param.minimumIteration + 3) {
                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.localCheckpoint();

                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSReflexivDouble, ReflexivLongKmerEncoder);

                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                ReflexivLongSubKmerDS.cache();

                ExtendableReflexivKmerPairs = ReflexivLongSubKmerDS.mapPartitions(DSReflexivExtendablePairs, ReflexivLongKmerEncoder);
                UnExtendableReflexivKmerPairs = ReflexivLongSubKmerDS.mapPartitions(DSReflexivUnExtendable, ReflexivLongKmerEncoder);

                ExtendableReflexivKmerPairs.cache();
                UnExtendableReflexivKmerPairs.cache();
                long extendablePairs = ExtendableReflexivKmerPairs.count();
                System.out.println("mark before extention, extandable pairs: " + extendablePairs);

                ExtendableReflexivKmerPairs = ExtendableReflexivKmerPairs.sort("k-1");
                UnExtendableReflexivKmerPairs = UnExtendableReflexivKmerPairs.sort("k-1");

                ExtendableReflexivKmer = ExtendableReflexivKmerPairs.mapPartitions(DSReflexivExtendable, ReflexivLongKmerEncoder);
                UnExtendableReflexivKmer = UnExtendableReflexivKmerPairs.mapPartitions(DSReflexivExtendable, ReflexivLongKmerEncoder);

                ExtendableReflexivKmer.cache();
                UnExtendableReflexivKmer.cache();

                long beforeExtensionExtendable = ExtendableReflexivKmer.count();
                long beforeExtensionUnExtendable = UnExtendableReflexivKmer.count();
                long allbeforeExtention = ReflexivLongSubKmerDS.count();

                System.out.println("mark before extention, extandable: " + beforeExtensionExtendable);
                System.out.println("mark before extention, unextandable: " + beforeExtensionUnExtendable);
                System.out.println("mark before extention, total: " + allbeforeExtention);

                ReflexivLongSubKmerDS.unpersist();
            }
*/
            if (iterations >= param.minimumIteration + 3 + 52) { // 15 + 3 is 18. for reduced iterations
                break;
                /*
                if (iterations % 3 == 0) {
                    ReflexivLongSubKmerDS.cache();
                    int partitionNumber = ReflexivLongSubKmerDS.toJavaRDD().getNumPartitions();

                    long currentContigNumber = 0;
                    currentContigNumber = ReflexivLongSubKmerDS.count();
                    System.out.println("mark iteration: " + iterations + " has kmers: " + currentContigNumber);

                    if (contigNumber == currentContigNumber) {
                        if (param.scramble == 2){
                            param.scramble =3;
                            contigNumber = currentContigNumber;
                        }else {
                            break;
                        }
                    } else {
                        contigNumber = currentContigNumber;
                    }

                    if (partitionNumber >= 16) {
                        if (currentContigNumber / partitionNumber <= 200) {
                            partitionNumber = partitionNumber / 4 + 1;
                            if (ReflexivLongSubKmerDS != null) {
                                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.repartition(partitionNumber);
                            }
                        }
                    }

                    ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                   // ReflexivLongSubKmerDS.unpersist();
                    ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongSubKmerEncoderCompressed);
                }else {

                    ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                    ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongSubKmerEncoderCompressed);
                }
                */
            }else {
               // ReflexivLongSubKmerDS.cache();
                //long IterationCount = ReflexivLongSubKmerDS.count();
               // System.out.println("mark iteration: " + iterations + " has kmers: " + IterationCount);
                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongSubKmerEncoderCompressed);
            }
        }

        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
       // ReflexivLongSubKmerStringDS = ReflexivLongSubKmerDS.mapPartitions(DSArrayStringOutput, ReflexivLongKmerStringEncoder);

        DSExtractFixingKmerFromContigEnds FixingKmerPreperation = new DSExtractFixingKmerFromContigEnds();
        ReflexivLongFullKmerDS= ReflexivLongSubKmerDS.mapPartitions(FixingKmerPreperation, KmerBinaryCountLongEncoder);

        ReflexivLongFullKmerDS.persist(StorageLevel.MEMORY_AND_DISK());

        DSgetFixingLongKmer FixingLongerKmerExtraction = new DSgetFixingLongKmer();
        FixingLongKmerDS = ReflexivLongFullKmerDS.mapPartitions(FixingLongerKmerExtraction, ReflexivFixingKmerEndocer);
/*
        if (param.gzip) {
            FixingLongKmerDS.write().
                    mode(SaveMode.Overwrite).
                    format("csv").
                    option("codec", "org.apache.hadoop.io.compress.GzipCodec").
                    save(param.outputPath + "/FixingLongKmer");
        }else{
            FixingLongKmerDS.write().
                    mode(SaveMode.Overwrite).
                    format("csv").
                    save(param.outputPath + "/FixingLongKmer");
        }
*/


        DSgetFixingKmer FixingKmerExtraction = new DSgetFixingKmer();
        FixingKmerDS = ReflexivLongFullKmerDS.mapPartitions(FixingKmerExtraction, kmerFixingEncoder);

//        DSBinaryFixingKmerToString BinaryKmerToString = new DSBinaryFixingKmerToString();
//        DSBinaryMixedFixingKmerToString BinaryMixedFixingKmerToString= new DSBinaryMixedFixingKmerToString();
        Dataset<Row> FixingKmerDSCount;
        StructType kmerCountTupleLongStruct = new StructType();
        kmerCountTupleLongStruct= kmerCountTupleLongStruct.add("kmer", DataTypes.StringType, false);
        kmerCountTupleLongStruct= kmerCountTupleLongStruct.add("count", DataTypes.LongType, false);
        ExpressionEncoder<Row> kmerCountEncoder = RowEncoder.apply(kmerCountTupleLongStruct);


        FixingKmerDSCount = FixingKmerDS.groupBy("kmer")
                .count()
                .toDF("kmer","count");
        // FixingKmerDSCount.cache();

        DSFixingKmerLeftAndRightMarkerAssignment FixingKmerLeftAndRight = new DSFixingKmerLeftAndRightMarkerAssignment();
        FixingKmerDSCount = FixingKmerDSCount.mapPartitions(FixingKmerLeftAndRight, ReflexivFixingKmerEndocer);

        FixingKmerDSCount = FixingKmerDSCount.union(FixingLongKmerDS);
        FixingKmerDSCount.persist(StorageLevel.MEMORY_AND_DISK());

        FixingKmerDSCount = FixingKmerDSCount.sort("k-1");

        DSFilterForkSubKmerWithErrorCorrection leftForkFilter =new DSFilterForkSubKmerWithErrorCorrection();
        FixingKmerDSCount= FixingKmerDSCount.mapPartitions(leftForkFilter, ReflexivFixingKmerEndocer);

        DSChangingFixingKmerToReflectedKmer FixingKmerReflectedChanging = new DSChangingFixingKmerToReflectedKmer();
        FixingKmerDSCount = FixingKmerDSCount.mapPartitions(FixingKmerReflectedChanging, ReflexivFixingKmerEndocer);

        FixingKmerDSCount = FixingKmerDSCount.sort("k-1");

        DSFilterForkReflectedSubKmerWithErrorCorrection rightForkFilter= new DSFilterForkReflectedSubKmerWithErrorCorrection();
        FixingKmerDSCount = FixingKmerDSCount.mapPartitions(rightForkFilter, ReflexivFixingKmerEndocer);

        DSExtendFixingKmerLoop FixingKmerExtensionLoop = new DSExtendFixingKmerLoop();

        FixingKmerDSCount = FixingKmerDSCount.mapPartitions(FixingKmerExtensionLoop, ReflexivFixingKmerEndocer);
        while (iterations <= param.maximumIteration) {
            iterations++;
            if (iterations >= param.minimumIteration + 3 + 52 + 30) {
                param.scramble=3;
            }

            if (iterations >= param.minimumIteration + 3 + 52 +30+18) {
                break;
            } else{
                FixingKmerDSCount  = FixingKmerDSCount.sort("k-1");
                FixingKmerDSCount = FixingKmerDSCount.mapPartitions(FixingKmerExtensionLoop, ReflexivFixingKmerEndocer);
            }
        }

        FixingKmerDSCount  = FixingKmerDSCount.sort("k-1");

        DSBinaryFixingKmerToFullKmer FixingKmer2FullKmer = new DSBinaryFixingKmerToFullKmer();

        FixingFullKmer = FixingKmerDSCount.mapPartitions(FixingKmer2FullKmer,markerTupleEncoder );

        ContigsRDDIndex = FixingFullKmer.toJavaRDD().zipWithIndex();

        markerTuple = spark.createDataset(ContigsRDDIndex.rdd(), Encoders.tuple(markerTupleEncoder, Encoders.LONG()));
       // markerTuple.persist(StorageLevel.MEMORY_AND_DISK());

        TagRowContigRDDID DSContigIDLabel = new TagRowContigRDDID();
        ContigDS = markerTuple.flatMap(DSContigIDLabel, Encoders.STRING());

       // markerTuple.persist(StorageLevel.MEMORY_AND_DISK());

        ContigDS.write().
                mode(SaveMode.Overwrite).
                format("csv").
                option("codec", "org.apache.hadoop.io.compress.GzipCodec").save(param.outputPath + "/Assembly_duplicated");

        DSTupleToDataset tuple2Dataset = new DSTupleToDataset();
        markerTupleRow = markerTuple.mapPartitions(tuple2Dataset, KmerBinaryCountLongEncoder);

        markerTupleRow.persist(StorageLevel.MEMORY_AND_DISK());

        ReverseComplementKmerMarkerExtraction MarkerKmerExtract = new ReverseComplementKmerMarkerExtraction();
        markerKmer = markerTupleRow.mapPartitions(MarkerKmerExtract, ReflexivKmerMarkerEncoder);

        // markerKmer.checkpoint();

        // markerKmer.persist(StorageLevel.MEMORY_AND_DISK());
/*
        DSBinaryMarkerKmerToString MarkerKmerToString = new DSBinaryMarkerKmerToString();
        markerKmerString = markerKmer.mapPartitions(MarkerKmerToString, ContigString3Encoder);

        markerKmerString.write().
                mode(SaveMode.Overwrite).
                format("csv").
                option("codec", "org.apache.hadoop.io.compress.GzipCodec").save(param.outputPath + "/Assembly_duplicated");
*/
        markerKmer= markerKmer.sort("kmerBinary");


        DSMarkerKmerSelection MarkerKmerRC = new DSMarkerKmerSelection();
        MarkerShorterKmerID = markerKmer.mapPartitions(MarkerKmerRC, kmerFixingEncoder);

        MarkerIDCount = MarkerShorterKmerID.groupBy("kmer")
                .count()
                .toDF("id","count");

        MarkerIDCount = MarkerIDCount.filter(col("count")
                        .geq(2) // minimal 2 k-mer seed matches
        );

        DSMarkerKmerShorterID getShorterKmerID = new DSMarkerKmerShorterID();
        markerShortIDRow = MarkerIDCount.mapPartitions(getShorterKmerID, KmerBinaryCountLongEncoder );

        markerTupleRow = markerTupleRow.union(markerShortIDRow);
        markerTupleRow.persist(StorageLevel.MEMORY_AND_DISK());

        markerTupleRow = markerTupleRow.sort("count");

        DSShorterRCContigSeqAndTargetExtraction RCContigSeqAndTarget = new DSShorterRCContigSeqAndTargetExtraction();

        markerTupleRow = markerTupleRow.mapPartitions(RCContigSeqAndTarget, KmerBinaryCountLongEncoder);

        markerTupleRow = markerTupleRow.sort("count");

        DSShorterRCContigRemoval shorterRemoval=new DSShorterRCContigRemoval();

        FixingFullKmer = markerTupleRow.mapPartitions(shorterRemoval, markerTupleEncoder);

        /**
         * round two, ready go
         */


        ContigsRDDIndex = FixingFullKmer.toJavaRDD().zipWithIndex();

        markerTuple = spark.createDataset(ContigsRDDIndex.rdd(), Encoders.tuple(markerTupleEncoder, Encoders.LONG()));

        markerTupleRow = markerTuple.mapPartitions(tuple2Dataset, KmerBinaryCountLongEncoder);

        markerTupleRow.persist(StorageLevel.MEMORY_AND_DISK());

        ForwardAndReverseComplementKmerMarkerExtraction bothMarkerKmerExtract = new ForwardAndReverseComplementKmerMarkerExtraction();
        markerKmer = markerTupleRow.mapPartitions(bothMarkerKmerExtract, ReflexivKmerMarkerEncoder);

        markerKmer= markerKmer.sort("kmerBinary");

        MarkerShorterKmerID = markerKmer.mapPartitions(MarkerKmerRC, kmerFixingEncoder);

        MarkerIDCount = MarkerShorterKmerID.groupBy("kmer")
                .count()
                .toDF("id","count");

        MarkerIDCount = MarkerIDCount.filter(col("count")
                .geq(2) // minimal 2 k-mer seed matches
        );

        markerShortIDRow = MarkerIDCount.mapPartitions(getShorterKmerID, KmerBinaryCountLongEncoder );

        markerTupleRow = markerTupleRow.union(markerShortIDRow);
        markerTupleRow.persist(StorageLevel.MEMORY_AND_DISK());

        markerTupleRow = markerTupleRow.sort("count");

        markerTupleRow = markerTupleRow.mapPartitions(RCContigSeqAndTarget, KmerBinaryCountLongEncoder);

        markerTupleRow = markerTupleRow.sort("count");

        DSShorterForwardAndRCContigRemoval shorterForwardAndRCRemoval=new DSShorterForwardAndRCContigRemoval();
        ContigDS = markerTupleRow.mapPartitions(shorterForwardAndRCRemoval, Encoders.STRING());

        ContigDS.persist(StorageLevel.MEMORY_AND_DISK());

        ContigsDSIndex = ContigDS.toJavaRDD().zipWithIndex();

        TagRowContigDSID DSIDLabel = new TagRowContigDSID();
        ContigRDD = ContigsDSIndex.flatMap(DSIDLabel);

        if (param.gzip) {
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly", GzipCodec.class);
        }else{
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly");
        }
 /*
        .write().
                mode(SaveMode.Overwrite).
                format("csv").
                option("codec", "org.apache.hadoop.io.compress.GzipCodec").save(param.outputPath + "/Assembly");

        spark.stop();
        sc.stop();

        FixingKmerDSString = FixingKmerDSCount.mapPartitions(BinaryMixedFixingKmerToString, ReflexivLongKmerStringEncoder);

        if (param.gzip) {
            FixingKmerDSString.write().
                    mode(SaveMode.Overwrite).
                    format("csv").
                    option("codec", "org.apache.hadoop.io.compress.GzipCodec").
                    save(param.outputPath + "/FixingKmer");
        }else{
            FixingKmerDSString.write().
                    mode(SaveMode.Overwrite).
                    format("csv").
                    save(param.outputPath + "/FixingKmer");
        }



        DSKmerToContig contigformaterDS = new DSKmerToContig();
        ContigRows = FixingKmerDSString.mapPartitions(contigformaterDS, ContigStringEncoder);

     //   ContigRows.cache();

        ContigRowsRDD = ContigRows.toJavaRDD();

        ContigsRDDIndex = ContigRowsRDD.zipWithIndex();

        TagRowContigID DSIdLabeling = new TagRowContigID();
        ContigRDD = ContigsRDDIndex.flatMap(DSIdLabeling);

        ContigRDD.cache();
        long filteredCountig = ContigRDD.count();
        System.out.println("mark contig number: " + filteredCountig);

        if (param.gzip) {
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly", GzipCodec.class);
        }else{
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly");
        }
*/
/*
        DSShortBranchRemovalPreparationLeft leftPreparationsForBranchRemoval = new DSShortBranchRemovalPreparationLeft();
        DSShortBranchRemovalLeftWhilePreparingForRight leftRemovalRightPrepartionForBranch = new DSShortBranchRemovalLeftWhilePreparingForRight();
        DSshortBranchRemovalRight rightMarkerRemovalForBranch= new DSshortBranchRemovalRight();

        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(leftPreparationsForBranchRemoval, ReflexivLongSubKmerEncoderCompressed);
        ReflexivLongSubKmerDS.cache();
        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(leftRemovalRightPrepartionForBranch, ReflexivLongSubKmerEncoderCompressed);
        ReflexivLongSubKmerDS.cache();
        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(rightMarkerRemovalForBranch, ReflexivLongSubKmerEncoderCompressed);
        ReflexivLongSubKmerDS.cache();
        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

        while (iterations <= param.maximumIteration +30) {
            iterations++;
            if (iterations % 3 == 0) {
                ReflexivLongSubKmerDS.cache();
                long currentContigNumber = 0;
                currentContigNumber = ReflexivLongSubKmerDS.count();
                System.out.println("mark iteration: " + iterations + " has kmers: " + currentContigNumber);

                if (contigNumber == currentContigNumber) {
                    if (param.scramble == 2){
                        param.scramble =3;
                        contigNumber = currentContigNumber;
                    }else {
                        break;
                    }
                } else {
                    contigNumber = currentContigNumber;
                }

                if (partitionNumber >= 16) {
                    if (currentContigNumber / partitionNumber <= 20) {
                        partitionNumber = partitionNumber / 4 + 1;
                        if (ReflexivLongSubKmerDS != null) {
                            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.coalesce(partitionNumber);
                        }
                    }
                }
            }

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongSubKmerEncoderCompressed);
        }
*/
/*
        if (ExtendableReflexivKmer != null && UnExtendableReflexivKmer!=null) {
            long extendableCount = ExtendableReflexivKmer.count();
            long unExtendableCount = UnExtendableReflexivKmer.count();
            System.out.println("mark after extention, extandable: " + extendableCount);
            System.out.println("mark after extention, unextandable: " + unExtendableCount);
            ReflexivLongSubKmerDS = ExtendableReflexivKmer.union(UnExtendableReflexivKmer);
            long afterextention = ReflexivLongSubKmerDS.count();
            System.out.println("mark after extention, all: " + afterextention);

            ReflexivLongSubKmerDS.cache();

            DSFilterUnExtendableKmerLeftEnds leftEndsFilter = new DSFilterUnExtendableKmerLeftEnds();
            DSFilterUnExtendableKmerRightEnds rightEndsFilter = new DSFilterUnExtendableKmerRightEnds();
            DSFilterStillExtendableKmerEnds EndsRemover = new DSFilterStillExtendableKmerEnds();

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(leftEndsFilter, ReflexivLongKmerEncoder);
            ReflexivLongSubKmerDS.cache();
            long longMark1 = ReflexivLongSubKmerDS.count();
            System.out.println("mark 1: " + longMark1);
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(EndsRemover, ReflexivLongKmerEncoder);
            ReflexivLongSubKmerDS.cache();
            long longMark2 = ReflexivLongSubKmerDS.count();
            System.out.println("mark 2: " + longMark2);

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(rightEndsFilter, ReflexivLongKmerEncoder);
            ReflexivLongSubKmerDS.cache();
            long longMark3 = ReflexivLongSubKmerDS.count();
            System.out.println("mark 3: " + longMark3);
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(EndsRemover, ReflexivLongKmerEncoder);
            ReflexivLongSubKmerDS.cache();
            long longMark4 = ReflexivLongSubKmerDS.count();
            System.out.println("mark 4: " + longMark4);

            ReflexivLongSubKmerDS.cache();
            long afterFilterExtention = ReflexivLongSubKmerDS.count();
            System.out.println("mark after extention all and filter ends: " + afterFilterExtention);


        }
        ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
*/
      /*  if (param.mercy) {

            DSLowCoverageSubKmerExtraction lowCoverageSubKmerExtractor = new DSLowCoverageSubKmerExtraction();

            ContigProbRows = ReflexivLongSubKmerDS.mapPartitions(lowCoverageSubKmerExtractor, ReflexivSubKmerProbEncoder);

            List<Row> ProbSubKmerArray = ContigProbRows.collectAsList();

            Hashtable<List<Long>, Integer> ProbSubKmerTable = SubKmerProbRowToHash(ProbSubKmerArray);
            final Broadcast<Hashtable<List<Long>, Integer>> ProbSubKmerArrayBroadCast = jsc.broadcast(ProbSubKmerTable);
            DSLowCoverageReadDetection LowCoverageReadDetector = new DSLowCoverageReadDetection(ProbSubKmerArrayBroadCast);


            FastqDS = spark.read().text(param.inputFqPath).as(Encoders.STRING());

            DSFastqFilterWithQual DSFastqFilter = new DSFastqFilterWithQual();
            FastqDS = FastqDS.map(DSFastqFilter, Encoders.STRING());

            DSFastqUnitFilter FilterDSUnit = new DSFastqUnitFilter();

            FastqDS = FastqDS.filter(FilterDSUnit);

            if (param.partitions > 0) {
                FastqDS = FastqDS.repartition(param.partitions);
            }
            if (param.cache) {
                FastqDS.cache();
            }

            ReflexivLongFragmentDS = FastqDS.mapPartitions(LowCoverageReadDetector, ReflexivLongKmerEncoder);
            ReflexivLongFragmentDS = ReflexivLongFragmentDS.sort("k-1");
            long beforeFilter = ReflexivLongFragmentDS.count();
            System.out.println("mark before low cover filter: " + beforeFilter);
            DSFilterRepeatLowCoverageFragment repeatLowCoverageFragmentFilter = new DSFilterRepeatLowCoverageFragment();
            ReflexivLongFragmentDS = ReflexivLongFragmentDS.mapPartitions(repeatLowCoverageFragmentFilter, ReflexivLongKmerEncoder);

            long afterFilter = ReflexivLongFragmentDS.count();
            System.out.println("mark after low cover filter: " + afterFilter);

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.union(ReflexivLongFragmentDS);
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongKmerEncoder);

            iterations = 6;

            while (iterations <= param.maximumIteration) {
                iterations++;
                if (iterations >= param.minimumIteration){
                    if (iterations % 3 == 0) {

                        /**
                         *  problem ------------------------------------------v
                         */
        /*
                        ReflexivLongSubKmerDS.cache();
                        long currentContigNumber = ReflexivLongSubKmerDS.count();
                        if (contigNumber == currentContigNumber) {
                            break;
                        } else {
                            contigNumber = currentContigNumber;
                        }

                        if (partitionNumber >= 16) {
                            if (currentContigNumber / partitionNumber <= 20) {
                                partitionNumber = partitionNumber / 4 + 1;
                                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.coalesce(partitionNumber);
                            }
                        }
                    }
                }

                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");
                ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.mapPartitions(DSKmerExtenstionArrayToArray, ReflexivLongKmerEncoder);
            }

            ReflexivLongSubKmerDS = ReflexivLongSubKmerDS.sort("k-1");

        }
        */

        /**
         *
         */

//        ReflexivLongSubKmerStringDS = ReflexivLongSubKmerDS.mapPartitions(DSArrayStringOutput, ReflexivLongKmerStringEncoder);

        /**
         *
         */
     //   DSKmerToContigLength contigLengthDS = new DSKmerToContigLength();
     //   ContigLengthRows = ReflexivLongSubKmerStringDS.mapPartitions(contigLengthDS, ContigLengthEncoder);


        // DSFormatContigs ContigFormater = new DSFormatContigs();
        // ContigRows= ContigMergedRow.mapPartitions(ContigFormater, ContigStringEncoder);



     //   DSKmerToContig contigformaterDS = new DSKmerToContig();

       // ContigRows = ReflexivLongSubKmerStringDS.mapPartitions(contigformaterDS, ContigStringEncoder);

        /**
         *
         */
/*
        ContigRowsRDD = ContigRows.toJavaRDD();

        ContigRowsRDD.cache();

        ContigsRDDIndex = ContigRowsRDD.zipWithIndex();

       // TagRowContigID DSIdLabeling = new TagRowContigID();
        ContigRDD = ContigsRDDIndex.flatMap(DSIdLabeling);

        ContigRDD.cache();
       //  long
                filteredCountig = ContigRDD.count();
        System.out.println("mark contig number: " + filteredCountig);

        if (param.gzip) {
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly", GzipCodec.class);
        }else{
            ContigRDD.saveAsTextFile(param.outputPath + "/Assembly");
        }
*/
        spark.stop();
    }

    class DSShorterForwardAndRCContigRemoval implements MapPartitionsFunction<Row, String>, Serializable{
        List<String> longerRCContig = new ArrayList<String>();
        List<Row> shortKmer = new ArrayList<Row>();
        Row longestKmer;
        boolean marker =false;
        int currentLength;
        int longestLength;

        public Iterator<String> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()){
                Row s= sIterator.next();

                if (longestKmer==null){
                    longestKmer=s;
                    longestLength=currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                    continue;
                }

                if (s.getLong(1) == longestKmer.getLong(1)) {
                    currentLength = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                    if (currentLength>longestLength){

                        shortKmer.add(longestKmer);
                        longestKmer = s;
                        longestLength=currentLength;
                    }else{
                        shortKmer.add(s);
                    }
                }else{
                    if (shortKmer.size()>0){
                        long[] longestContigBlock = seq2array(longestKmer.getSeq(0));
                        for (int i=0;i<shortKmer.size();i++){
                            longestContigBlock=merge2RCContigs(longestContigBlock,seq2array(shortKmer.get(i).getSeq(0)));
                        }

                        longerRCContig.add(BinaryBlocksToString(longestContigBlock));

                        shortKmer = new ArrayList<Row>();
                    }else {
                        longerRCContig.add(BinaryBlocksToString(seq2array(longestKmer.getSeq(0))));
                    }

                    longestKmer = s;
                    longestLength= currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));

                }

            }

            if (shortKmer.size()>0){
                long[] longestContigBlock = seq2array(longestKmer.getSeq(0));
                for (int i=0;i<shortKmer.size();i++){
                    merge2RCContigs(longestContigBlock,seq2array(shortKmer.get(i).getSeq(0)));
                }
                longerRCContig.add(BinaryBlocksToString(longestContigBlock));
            }else{
                longerRCContig.add(BinaryBlocksToString(seq2array(longestKmer.getSeq(0))));
            }

            return longerRCContig.iterator();
        }

        private long[] merge2RCContigs(long[] longContig, long[] RCshortContig) throws Exception {
            List<Integer> distanceList = new ArrayList<Integer>();
            HashMap<Integer, List<Integer>> kmerCoordinates = new HashMap<Integer, List<Integer>>();
            int kmerSeedLength = 15;
            List<Integer> coordinates;


            int longContigLength = currentKmerSizeFromBinaryBlockArray(longContig);

            for (int i=0; i<=longContigLength; i+=kmerSeedLength){
                long[] kmerSeed = leftShiftArray(longContig,i);
                kmerSeed= leftShiftOutFromArray(kmerSeed, kmerSeedLength);
                int kmerSeedInt = (int) (kmerSeed[0] >>> 2*(32-kmerSeedLength));  // remove C marker in the end

                if (kmerCoordinates.containsKey(kmerSeed)){
                    kmerCoordinates.get(kmerSeed).add(i+1);
                }else{
                    coordinates=new ArrayList<Integer>();
                    coordinates.add(i+1);
                    kmerCoordinates.put(kmerSeedInt, coordinates);
                }

            }

            // for forward strand



            int forwardContigLength = currentKmerSizeFromBinaryBlockArray(RCshortContig);

            for (int i=0;i < forwardContigLength; i++){
                long[] kmerQuery = leftShiftArray(RCshortContig, i);
                kmerQuery = leftShiftOutFromArray(kmerQuery, kmerSeedLength);
                int kmerQueryInt= (int) (kmerQuery[0] >>> 2*(32-kmerSeedLength));

                if (kmerCoordinates.containsKey(kmerQueryInt)){
                    for (int seedLocus : kmerCoordinates.get(kmerQueryInt)) {
                        distanceList.add(i+1-seedLocus);
                    }
                }
            }

            Collections.sort(distanceList);

            int totalMatches = distanceList.size();
            int lastDistance=0;
            int lastFrequency=0;
            int finalDistance=-1;

            for (int distance : distanceList){
                if (distance - lastDistance >=-1 && distance - lastDistance <=1  ){
                    lastFrequency++;
                    if ((double)lastFrequency/totalMatches>=0.7 && lastFrequency >=7){ // at least 8 15-mer matches
                        finalDistance=distance;
                        break;
                    }
                }else{
                    lastFrequency=1;
                    lastDistance=distance;
                }
            }

            if (finalDistance==-1){ // not enough 15mer match was found, adding short Contig back to the pool
                // skip and check RC
            }else if (finalDistance == 0){ // one side perfectly aligned
                // return longContig;

            }else if (finalDistance <0){
                //  |--------------------------|            longLength
                //   xxxxxxxxxxxx                           -finalDistance
                //               |------------------|       shortLength

                int shortRightSideFlank = forwardContigLength - (longContigLength + finalDistance);
                if (shortRightSideFlank >0){
                    long[] rightFlankBlock = leftShiftArray(RCshortContig,forwardContigLength-shortRightSideFlank);
                    longContig= combineTwoLongBlocks(longContig, rightFlankBlock);
                    return longContig; // stop and without RC
                }else{
                    // return longContig
                }
            }else{ // finalDistance >0
                //       |--------------------------|       longLength
                //  |----------------|                      shortLength

                long[] leftFlankBlock = leftShiftOutFromArray(RCshortContig, finalDistance);
                longContig= combineTwoLongBlocks(leftFlankBlock, longContig);
                return longContig;
            }


            // for reverse complement

            long[] shortContig = binaryBlockReverseComplementary(RCshortContig);
            int shortContigLength = currentKmerSizeFromBinaryBlockArray(shortContig);

            for (int i=0;i < shortContigLength; i++){
                long[] kmerQuery = leftShiftArray(shortContig, i);
                kmerQuery = leftShiftOutFromArray(kmerQuery, kmerSeedLength);
                int kmerQueryInt= (int) (kmerQuery[0] >>> 2*(32-kmerSeedLength));

                if (kmerCoordinates.containsKey(kmerQueryInt)){
                    for (int seedLocus : kmerCoordinates.get(kmerQueryInt)) {
                        distanceList.add(i+1-seedLocus);
                    }
                }
            }

            Collections.sort(distanceList);

            totalMatches = distanceList.size();
            lastDistance=0;
            lastFrequency=0;
            finalDistance=-1;

            for (int distance : distanceList){
                if (distance - lastDistance >=-1 && distance - lastDistance <=1  ){
                    lastFrequency++;
                    if ((double)lastFrequency/totalMatches>=0.7 && lastFrequency >=7){ // at least 8 15-mer matches
                        finalDistance=distance;
                        break;
                    }
                }else{
                    lastFrequency=1;
                    lastDistance=distance;
                }
            }

            if (finalDistance==-1){ // not enough 15mer match was found, adding short Contig back to the pool
                longerRCContig.add(BinaryBlocksToString(RCshortContig));
                // return longContig;
            }else if (finalDistance == 0){ // one side perfectly aligned
                // return longContig;

            }else if (finalDistance <0){
                //  |--------------------------|            longLength
                //   xxxxxxxxxxxx                           -finalDistance
                //               |------------------|       shortLength

                int shortRightSideFlank = shortContigLength - (longContigLength + finalDistance);
                if (shortRightSideFlank >0){
                    long[] rightFlankBlock = leftShiftArray(shortContig,shortContigLength-shortRightSideFlank);
                    longContig= combineTwoLongBlocks(longContig, rightFlankBlock);

                }else{
                    // return longContig
                }
            }else{ // finalDistance >0
                //       |--------------------------|       longLength
                //  |----------------|                      shortLength

                long[] leftFlankBlock = leftShiftOutFromArray(shortContig, finalDistance);
                longContig= combineTwoLongBlocks(leftFlankBlock, longContig);
            }




            return longContig;
        }

        private long[] binaryBlockReverseComplementary(long[] forward){
            int currentKmerResidue = currentKmerResidueFromBlockArray(forward);
            int currentKmerSize = currentKmerSizeFromBinaryBlockArray(forward);
            int currentKmerBlockSize=forward.length;
            long[] reverseComplement;
            long lastTwoBits;

            reverseComplement = new long[currentKmerBlockSize];

            for (int i = 0; i < currentKmerSize; i++) {
                int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                //  ------------- ------------- -------**----  <--
                // reverseComplement[i / 31] <<= 2;

                if (RCindex >= currentKmerSize - currentKmerResidue) {
                    lastTwoBits = forward[RCindex / 31] >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                } else { // the same
                    lastTwoBits = forward[RCindex / 31] >>> 2 * (32 - (RCindex % 31) - 1);
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                }

                reverseComplement[i / 31] |= lastTwoBits;
                reverseComplement[i / 31] <<=2; // the order of these two lines are very important

            }
            reverseComplement[(currentKmerSize-1)/31] <<= 2*(32-currentKmerResidue-1); //  ---xxxxxxx -> xxxxxxx--- extra -1 because there are a vacancy from the step above
            reverseComplement[(currentKmerSize-1)/31]|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C

            return reverseComplement;
        }

        private int currentKmerResidueFromBlockArray(long[] binaryBlocks){
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[binaryBlocks.length-1]);
            return Long.SIZE/2 - suffix0s/2 -1;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }


    }

    class DSShorterRCContigRemoval implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> longerRCContig = new ArrayList<Row>();
        List<Row> shortKmer = new ArrayList<Row>();
        Row longestKmer;
        boolean marker =false;
        int currentLength;
        int longestLength;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()){
                Row s= sIterator.next();

                if (longestKmer==null){
                    longestKmer=s;
                    longestLength=currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                    continue;
                }

                if (s.getLong(1) == longestKmer.getLong(1)) {
                    currentLength = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                    if (currentLength>longestLength){

                        shortKmer.add(longestKmer);
                        longestKmer = s;
                        longestLength=currentLength;
                    }else{
                        shortKmer.add(s);
                    }
                }else{
                    if (shortKmer.size()>0){
                        long[] longestContigBlock = seq2array(longestKmer.getSeq(0));
                        for (int i=0;i<shortKmer.size();i++){
                            longestContigBlock=merge2RCContigs(longestContigBlock,seq2array(shortKmer.get(i).getSeq(0)));
                        }

                        longerRCContig.add(RowFactory.create(longestContigBlock));

                        shortKmer = new ArrayList<Row>();
                    }else {
                        longerRCContig.add(RowFactory.create(seq2array(longestKmer.getSeq(0))));
                    }

                    longestKmer = s;
                    longestLength= currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));

                }

            }

            if (shortKmer.size()>0){
                long[] longestContigBlock = seq2array(longestKmer.getSeq(0));
                for (int i=0;i<shortKmer.size();i++){
                    merge2RCContigs(longestContigBlock,seq2array(shortKmer.get(i).getSeq(0)));
                }
                longerRCContig.add(RowFactory.create(longestContigBlock));
            }else{
                longerRCContig.add(RowFactory.create(seq2array(longestKmer.getSeq(0))));
            }

            return longerRCContig.iterator();
        }

        private long[] merge2RCContigs(long[] longContig, long[] RCshortContig) throws Exception {
            List<Integer> distanceList = new ArrayList<Integer>();
            HashMap<Integer, List<Integer>> kmerCoordinates = new HashMap<Integer, List<Integer>>();
            int kmerSeedLength = 15;
            List<Integer> coordinates;


            int longContigLength = currentKmerSizeFromBinaryBlockArray(longContig);

            for (int i=0; i<=longContigLength; i+=kmerSeedLength){
                long[] kmerSeed = leftShiftArray(longContig,i);
                kmerSeed= leftShiftOutFromArray(kmerSeed, kmerSeedLength);
                int kmerSeedInt = (int) (kmerSeed[0] >>> 2*(32-kmerSeedLength));  // remove C marker in the end

                if (kmerCoordinates.containsKey(kmerSeed)){
                    kmerCoordinates.get(kmerSeed).add(i+1);
                }else{
                    coordinates=new ArrayList<Integer>();
                    coordinates.add(i+1);
                    kmerCoordinates.put(kmerSeedInt, coordinates);
                }

            }

            long[] shortContig = binaryBlockReverseComplementary(RCshortContig);
            int shortContigLength = currentKmerSizeFromBinaryBlockArray(shortContig);

            for (int i=0;i < shortContigLength; i++){
                long[] kmerQuery = leftShiftArray(shortContig, i);
                kmerQuery = leftShiftOutFromArray(kmerQuery, kmerSeedLength);
                int kmerQueryInt= (int) (kmerQuery[0] >>> 2*(32-kmerSeedLength));

                if (kmerCoordinates.containsKey(kmerQueryInt)){
                    for (int seedLocus : kmerCoordinates.get(kmerQueryInt)) {
                        distanceList.add(i+1-seedLocus);
                    }
                }
            }

            Collections.sort(distanceList);

            int totalMatches = distanceList.size();
            int lastDistance=0;
            int lastFrequency=0;
            int finalDistance=-1;

            for (int distance : distanceList){
                if (distance - lastDistance >=-1 && distance - lastDistance <=1  ){
                    lastFrequency++;
                    if ((double)lastFrequency/totalMatches>=0.7 && lastFrequency >=7){ // at least 8 15-mer matches
                        finalDistance=distance;
                        break;
                    }
                }else{
                    lastFrequency=1;
                    lastDistance=distance;
                }
            }

            if (finalDistance==-1){ // not enough 15mer match was found, adding short Contig back to the pool
                longerRCContig.add(RowFactory.create(RCshortContig));
                // return longContig;
            }else if (finalDistance == 0){ // one side perfectly aligned
                // return longContig;

            }else if (finalDistance <0){
                //  |--------------------------|            longLength
                //   xxxxxxxxxxxx                           -finalDistance
                //               |------------------|       shortLength

                int shortRightSideFlank = shortContigLength - (longContigLength + finalDistance);
                if (shortRightSideFlank >0){
                    long[] rightFlankBlock = leftShiftArray(shortContig,shortContigLength-shortRightSideFlank);
                    longContig= combineTwoLongBlocks(longContig, rightFlankBlock);

                }else{
                    // return longContig
                }
            }else{ // finalDistance >0
                //       |--------------------------|       longLength
                //  |----------------|                      shortLength

                long[] leftFlankBlock = leftShiftOutFromArray(shortContig, finalDistance);
                longContig= combineTwoLongBlocks(leftFlankBlock, longContig);
            }




            return longContig;
        }

        private long[] binaryBlockReverseComplementary(long[] forward){
            int currentKmerResidue = currentKmerResidueFromBlockArray(forward);
            int currentKmerSize = currentKmerSizeFromBinaryBlockArray(forward);
            int currentKmerBlockSize=forward.length;
            long[] reverseComplement;
            long lastTwoBits;

            reverseComplement = new long[currentKmerBlockSize];

            for (int i = 0; i < currentKmerSize; i++) {
                int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                //  ------------- ------------- -------**----  <--
                // reverseComplement[i / 31] <<= 2;

                if (RCindex >= currentKmerSize - currentKmerResidue) {
                    lastTwoBits = forward[RCindex / 31] >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                } else { // the same
                    lastTwoBits = forward[RCindex / 31] >>> 2 * (32 - (RCindex % 31) - 1);
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                }

                reverseComplement[i / 31] |= lastTwoBits;
                reverseComplement[i / 31] <<=2; // the order of these two lines are very important

            }
            reverseComplement[(currentKmerSize-1)/31] <<= 2*(32-currentKmerResidue-1); //  ---xxxxxxx -> xxxxxxx--- extra -1 because there are a vacancy from the step above
            reverseComplement[(currentKmerSize-1)/31]|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C

            return reverseComplement;
        }

        private int currentKmerResidueFromBlockArray(long[] binaryBlocks){
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[binaryBlocks.length-1]);
            return Long.SIZE/2 - suffix0s/2 -1;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }


    }

    class DSMarkerKmerSelection implements MapPartitionsFunction<Row, Row>, Serializable{
        Row LongestKmer = RowFactory.create(1L, 1L);
        List<Row> shorterKmer=new ArrayList<Row>();
        List<Row> contigID = new ArrayList<Row>();
        List<Row> kmerList = new ArrayList<Row>();
        long[] kmerArray = new long[1];


        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                Row s = sIterator.next();

                int reflexivMarker = getReflexivMarker(s.getLong(1));

                if (reflexivMarker==1){
                    if (s.getLong(0) == LongestKmer.getLong(0)){
                        if (getLeftMarker(s.getLong(1)) > getLeftMarker(LongestKmer.getLong(1))){
                            LongestKmer =s; // new kmer is longer
                        }
                    }else { // a new kmer
                        for (int i = 0; i < shorterKmer.size(); i++) {
                            if (shorterKmer.get(i).getLong(0) == LongestKmer.getLong(0)) {
                                if (getLeftMarker(shorterKmer.get(i).getLong(1)) < getLeftMarker(LongestKmer.getLong(1)) ) {
                                   // kmerArray[0] = shorterKmer.get(i).getLong(0);
                                   // kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(LongestKmer.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(LongestKmer.getLong(1)))));

                                    contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(LongestKmer.getLong(1)) ), 1));
                                } else if (getLeftMarker(shorterKmer.get(i).getLong(1)) == getLeftMarker(LongestKmer.getLong(1))) { // equal length, choose the earlier one
                                    if (getRightMarker(shorterKmer.get(i).getLong(1)) > getRightMarker(LongestKmer.getLong(1))) {
                                        //kmerArray[0] = shorterKmer.get(i).getLong(0);
                                       // kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(LongestKmer.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(LongestKmer.getLong(1)))));
                                        contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(LongestKmer.getLong(1)) ), 1));
                                    }
                                }
                            } else if (shorterKmer.get(i).getLong(0) == s.getLong(0)) {
                                if (getLeftMarker(shorterKmer.get(i).getLong(1)) < getLeftMarker(s.getLong(1)) ) {
                                   // kmerArray[0] = shorterKmer.get(i).getLong(0);
                                   // kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(s.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(s.getLong(1)))));
                                    contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(s.getLong(1)) ), 1));
                                } else if (getLeftMarker(shorterKmer.get(i).getLong(1)) == getLeftMarker(s.getLong(1))) {
                                    if (getRightMarker(shorterKmer.get(i).getLong(1)) > getRightMarker(s.getLong(1))) {
                                     //   kmerArray[0] = shorterKmer.get(i).getLong(0);
                                     //   kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(s.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(s.getLong(1)))));
                                        contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(s.getLong(1)) ), 1));
                                    }
                                }
                            }
                        }
                        LongestKmer = s;
                        shorterKmer = new ArrayList<Row>();

                    }
                }else{ // RC k-mer
                    shorterKmer.add(s);

                }

            }

            for (int i=0; i<shorterKmer.size(); i++){
                if (shorterKmer.get(i).getLong(0) == LongestKmer.getLong(0) ) {
                    if (getLeftMarker(shorterKmer.get(i).getLong(1)) < getLeftMarker(LongestKmer.getLong(1)) ) {
                      //  kmerArray[0]= shorterKmer.get(i).getLong(0);
                      //  kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(LongestKmer.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(LongestKmer.getLong(1)))));
                        contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(LongestKmer.getLong(1)) ),1) );
                    }else if (getLeftMarker(shorterKmer.get(i).getLong(1)) == getLeftMarker(LongestKmer.getLong(1))){
                        if (getRightMarker(shorterKmer.get(i).getLong(1)) > getRightMarker(LongestKmer.getLong(1))){
                           // kmerArray[0]= shorterKmer.get(i).getLong(0);
                           // kmerList.add(RowFactory.create(BinaryBlocksToString(kmerArray), String.valueOf(getLeftMarker(shorterKmer.get(i).getLong(1))), String.valueOf(getLeftMarker(LongestKmer.getLong(1))), String.valueOf(getRightMarker(shorterKmer.get(i).getLong(1))),String.valueOf(getRightMarker(LongestKmer.getLong(1)))));

                            contigID.add(RowFactory.create(buildingAlongFromTwoInt(getRightMarker(shorterKmer.get(i).getLong(1)), getRightMarker(LongestKmer.getLong(1)) ), 1) );
                            //contigID.add(getRightMarker((int) shorterKmer.get(i).getLong(1)));
                        }
                    }
                }
            }

    //        return kmerList.iterator();
            return contigID.iterator();
        }


        private long buildingAlongFromTwoInt(int leftCover, int rightCover){
            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            long info;

            info = ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>500000000){
                leftMarker=500000000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>1000000000){
                rightMarker=1000000000-rightMarker;
            }

            return rightMarker;
        }

        private long binaryLongReverseComplementary(long forward, int currentKmerSize){
            int currentKmerResidue =31;
            long reverseComplement=0;
            long lastTwoBits;

            for (int i = 0; i < currentKmerSize; i++) {
                int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                //  ------------- ------------- -------**----  <--
                // reverseComplement[i / 31] <<= 2;

                if (RCindex >= currentKmerSize - currentKmerResidue) {
                    lastTwoBits = forward >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                } else { // the same
                    lastTwoBits =  forward >>> 2 * (32 - (RCindex % 31) - 1);
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                }

                reverseComplement |= lastTwoBits;
                reverseComplement <<=2; // the order of these two lines are very important

            }
            reverseComplement <<= 2*(32-currentKmerResidue-1); //  ---xxxxxxx -> xxxxxxx--- extra -1 because there are a vacancy from the step above
            reverseComplement|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C

            return reverseComplement;

        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            //       String arrayAString = BinaryBlocksToString(arrayA);
            //       String arrayBString = BinaryBlocksToString(arrayB);
            if (aLength==bLength){
                //       System.out.println("equal comparator: " + arrayAString + " B: " + arrayBString);

            }

            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }
    }

    class DSTupleToDataset implements  MapPartitionsFunction<Tuple2<Row, Long>, Row>, Serializable{
        List<Row> MarkerKmerList = new ArrayList<Row>();
        long[] fullKmerArray;

        public Iterator<Row> call(Iterator<Tuple2<Row, Long>> sIterator) throws Exception {
            while (sIterator.hasNext()){
                Tuple2<Row, Long> sTuple =sIterator.next();
                Row s = sTuple._1;
                fullKmerArray = (long[])s.get(0);

                MarkerKmerList.add(RowFactory.create(fullKmerArray,sTuple._2));
            }

            return MarkerKmerList.iterator();
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }
    }

    class ForwardAndReverseComplementKmerMarkerExtraction implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> RCMarkerKmerList = new ArrayList<Row>();
        long maxKmerBinary =(~0L) << 2;
        long[] fullKmerArray;
        int kmerLength;
        int MarkerKmerSize =31;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                Row s = sIterator.next();
                fullKmerArray =  seq2array(s.getSeq(0));
                kmerLength = currentKmerSizeFromBinaryBlockArray(fullKmerArray);
                if (kmerLength >= 300 && kmerLength >= param.minContig) {

                    getForwardKmerBinary(fullKmerArray, s.getLong(1), kmerLength);
                    getRCKmerProbBinary(fullKmerArray, s.getLong(1), kmerLength);
                }
            }

            return RCMarkerKmerList.iterator();
        }

        private void getForwardKmerBinary(long[] kmerArray, long ID, int length){
            long seedKmer;

            long attribute = buildingAlongFromThreeInt(1,length, (int) ID); // 1 is forward seeding k-mer


            for (int i= 0; i<kmerArray.length-1; i++){
                seedKmer = ( kmerArray[i] & maxKmerBinary);
                seedKmer|=1L; // add C marker

                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }

            if (length % 31==0) {
                seedKmer = kmerArray[kmerArray.length - 1];
                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }
        }

        private void getRCKmerProbBinary(long[] kmerArray, long ID, int length) throws Exception {
            long seedKmer;
            long[] seedKmerArray;

            long attribute = buildingAlongFromThreeInt(2, length, (int) ID); // 2 is shorter RC prob k-mer


            if (length>=4000){

                for (int i = 0; i < MarkerKmerSize; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);

                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }


                for (int i = 1000 - MarkerKmerSize+1; i < 1000; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }


                for (int i = (length - 2 * MarkerKmerSize) / 2; i < (length - 2 * MarkerKmerSize) / 2 + MarkerKmerSize; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }

                for (int i = length -1000 - MarkerKmerSize +1; i < length - 1000; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }

                for (int j = length - 2 * MarkerKmerSize; j < length - MarkerKmerSize; j++) {
                    seedKmerArray = leftShiftArray(kmerArray, j);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }


            }else {

                // --------------------------------
                //                                -------------------------------- // 61 nt
                for (int i = 0; i < MarkerKmerSize; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);


                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }

                for (int i = (length - 2 * MarkerKmerSize) / 3; i < (length - 2 * MarkerKmerSize) / 3 + MarkerKmerSize; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }

                for (int i = (length - 2 * MarkerKmerSize) * 2 / 3; i < (length - 2 * MarkerKmerSize) * 2 / 3 + MarkerKmerSize; i++) {
                    seedKmerArray = leftShiftArray(kmerArray, i);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    // reverse complement binary
                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }

                for (int j = length - 2 * MarkerKmerSize; j < length - MarkerKmerSize; j++) {
                    seedKmerArray = leftShiftArray(kmerArray, j);
                    seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                    seedKmer = seedKmerArray[0];

                    // forward binary
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));

                    seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                    RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
                }
            }




        }

        private long binaryLongReverseComplementary(long forward, int currentKmerSize){
            int currentKmerResidue =31;
            long reverseComplement=0;
            long lastTwoBits;

            for (int i = 0; i < currentKmerSize; i++) {
                int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                //  ------------- ------------- -------**----  <--
                // reverseComplement[i / 31] <<= 2;

                if (RCindex >= currentKmerSize - currentKmerResidue) {
                    lastTwoBits = forward >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                } else { // the same
                    lastTwoBits =  forward >>> 2 * (32 - (RCindex % 31) - 1);
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                }

                reverseComplement |= lastTwoBits;
                reverseComplement <<=2; // the order of these two lines are very important

            }
            reverseComplement <<= 2*(32-currentKmerResidue-1); //  ---xxxxxxx -> xxxxxxx--- extra -1 because there are a vacancy from the step above
            reverseComplement|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C

            return reverseComplement;

        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=500000000){
                leftCover=500000000;
            }else if (leftCover<=-500000000){
                leftCover=500000000-(-500000000);
            }else if (leftCover<0){
                leftCover=500000000-leftCover;
            }

            if (rightCover>=1000000000){
                rightCover=1000000000;
            }else if (rightCover<=-1000000000){
                rightCover=2000000000;
            }else if (rightCover<0){
                rightCover=1000000000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

    }

    class ReverseComplementKmerMarkerExtraction implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> RCMarkerKmerList = new ArrayList<Row>();
        long maxKmerBinary =(~0L) << 2;
        long[] fullKmerArray;
        int kmerLength;
        int MarkerKmerSize =31;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                Row s = sIterator.next();
                fullKmerArray =  seq2array(s.getSeq(0));
                kmerLength = currentKmerSizeFromBinaryBlockArray(fullKmerArray);
                if (kmerLength >= 300 && kmerLength >= param.minContig) {

                    getForwardKmerBinary(fullKmerArray, s.getLong(1), kmerLength);
                    getRCKmerProbBinary(fullKmerArray, s.getLong(1), kmerLength);
                }
            }

            return RCMarkerKmerList.iterator();
        }

        private void getForwardKmerBinary(long[] kmerArray, long ID, int length){
            long seedKmer;

            long attribute = buildingAlongFromThreeInt(1,length, (int) ID); // 1 is forward seeding k-mer


            for (int i= 0; i<kmerArray.length-1; i++){
                seedKmer = ( kmerArray[i] & maxKmerBinary);
                seedKmer|=1L; // add C marker

                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }

            if (length % 31==0) {
                seedKmer = kmerArray[kmerArray.length - 1];
                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }
        }

        private void getRCKmerProbBinary(long[] kmerArray, long ID, int length) throws Exception {
            long seedKmer;
            long[] seedKmerArray;

            long attribute = buildingAlongFromThreeInt(2, length, (int) ID); // 2 is shorter RC prob k-mer

            // --------------------------------
            //                                -------------------------------- // 61 nt
            for (int i = 0; i < MarkerKmerSize; i++) {
                seedKmerArray = leftShiftArray(kmerArray, i);
                seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                seedKmer = seedKmerArray[0];

                // reverse complement binary
                seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);


                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }

            for (int i=(length-2*MarkerKmerSize)/3; i<(length-2*MarkerKmerSize)/3 + MarkerKmerSize ; i++){
                seedKmerArray = leftShiftArray(kmerArray, i);
                seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                seedKmer = seedKmerArray[0];

                // reverse complement binary
                seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }

            for (int i=(length-2*MarkerKmerSize)*2/3; i<(length-2*MarkerKmerSize)*2/3+MarkerKmerSize; i++){
                seedKmerArray = leftShiftArray(kmerArray, i);
                seedKmerArray = leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                seedKmer = seedKmerArray[0];

                // reverse complement binary
                seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }

            for (int j= length-2*MarkerKmerSize; j<length -MarkerKmerSize; j++){
                seedKmerArray = leftShiftArray(kmerArray, j);
                seedKmerArray =leftShiftOutFromArray(seedKmerArray, MarkerKmerSize);
                seedKmer = seedKmerArray[0];

                seedKmer = binaryLongReverseComplementary(seedKmer, MarkerKmerSize);
                RCMarkerKmerList.add(RowFactory.create(seedKmer, attribute));
            }




        }

        private long binaryLongReverseComplementary(long forward, int currentKmerSize){
            int currentKmerResidue =31;
            long reverseComplement=0;
            long lastTwoBits;

            for (int i = 0; i < currentKmerSize; i++) {
                int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                //  ------------- ------------- -------**----  <--
                // reverseComplement[i / 31] <<= 2;

                if (RCindex >= currentKmerSize - currentKmerResidue) {
                    lastTwoBits = forward >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                } else { // the same
                    lastTwoBits =  forward >>> 2 * (32 - (RCindex % 31) - 1);
                    lastTwoBits &= 3L;
                    lastTwoBits ^= 3L;
                }

                reverseComplement |= lastTwoBits;
                reverseComplement <<=2; // the order of these two lines are very important

            }
            reverseComplement <<= 2*(32-currentKmerResidue-1); //  ---xxxxxxx -> xxxxxxx--- extra -1 because there are a vacancy from the step above
            reverseComplement|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C

            return reverseComplement;

        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=500000000){
                leftCover=500000000;
            }else if (leftCover<=-500000000){
                leftCover=500000000-(-500000000);
            }else if (leftCover<0){
                leftCover=500000000-leftCover;
            }

            if (rightCover>=1000000000){
                rightCover=1000000000;
            }else if (rightCover<=-1000000000){
                rightCover=2000000000;
            }else if (rightCover<0){
                rightCover=1000000000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

    }

    class DSBinaryFixingKmerToFullKmer implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> reflexivKmerStringList = new ArrayList<Row>();

        long[] subKmerArray = new long[1];
        long[] combinedArray;


        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                Row s = sIterator.next();

                subKmerArray[0]=s.getLong(0);

                if (getReflexivMarker(s.getLong(1)) ==1){
                    combinedArray = combineTwoLongBlocks( subKmerArray, seq2array(s.getSeq(2)));
                }else{
                    combinedArray = combineTwoLongBlocks( seq2array(s.getSeq(2)), subKmerArray );
                }


                if (currentKmerSizeFromBinaryBlockArray(combinedArray) < param.minContig){
                    continue;
                }


                reflexivKmerStringList.add(
                        RowFactory.create(combinedArray)
                );
            }
            return reflexivKmerStringList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }
    }

    class DSBinaryMarkerKmerToString implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> reflexivKmerStringList = new ArrayList<Row>();
        int FixedKmerSize=31;
        long[] subKmerArray = new long[1];

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                String subKmer;

                Row s = sIterator.next();

                subKmerArray[0]=s.getLong(0);
                /*
                if (getReflexivMarker(s.getLong(1)) ==1){
                    combinedArray = combineTwoLongBlocks( subKmerArray, seq2array(s.getSeq(2)));
                }else{
                    combinedArray = combineTwoLongBlocks( seq2array(s.getSeq(2)), subKmerArray );
                }
*/
                subKmer = BinaryBlocksToString(subKmerArray);

                reflexivKmerStringList.add(
                        RowFactory.create(
                                subKmer, String.valueOf(getLeftMarker(s.getLong(1))), String.valueOf(getRightMarker(s.getLong(1))) )
                );
            }
            return reflexivKmerStringList.iterator();
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>500000000){
                leftMarker=500000000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>1000000000){
                rightMarker=1000000000-rightMarker;
            }

            return rightMarker;
        }


        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }
    }

    class TagContigArrayID implements PairFlatMapFunction<Tuple2<Row, Long>, Long[], Long>, Serializable {

        public Iterator<Tuple2<Long[], Long>> call(Tuple2<Row, Long> s) {


            List<Tuple2<Long[], Long>> markerKmerList = new ArrayList<Tuple2<Long[], Long>>();

            markerKmerList.add(new Tuple2<Long[], Long>(seq2array(s._1.getSeq(0)), s._2 ));

            return markerKmerList.iterator();
        }

        private Long[] seq2array(Seq a){
            Long[] array =new Long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

    }

    class DSShorterRCContigSeqAndTargetExtraction implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> shorterContigTarget = new ArrayList<Row>();
        Row lastKmer;
        boolean marker =false;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()){
                Row s= sIterator.next();

                if (lastKmer==null){
                    lastKmer=s;
                    continue;
                }

                if (s.getLong(1) == lastKmer.getLong(1)) {

                    if (seq2array(s.getSeq(0))[0] == -1L) {
                        shorterContigTarget.add(RowFactory.create(lastKmer.getSeq(0),seq2array(s.getSeq(0))[1]));
                    }else if (seq2array(lastKmer.getSeq(0))[0] == -1L){
                        shorterContigTarget.add(RowFactory.create(s.getSeq(0), seq2array(lastKmer.getSeq(0))[1])); // using target's ID for next step
                    }
                    lastKmer=null;
                }else{
                    shorterContigTarget.add(lastKmer);
                    lastKmer=s;
                }

            }

            if (lastKmer!=null){
                shorterContigTarget.add(lastKmer);
            }

            return shorterContigTarget.iterator();
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

    }


    class DSMarkerKmerShorterID implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList= new ArrayList<Row>();
        int shorterID;
        long[] subKmerArray;


        public Iterator<Row> call(Iterator<Row> s) throws Exception {

            while (s.hasNext()){
                Row subKmer=s.next();

                subKmerArray= new long[2];
                subKmerArray[0]=-1L;

                shorterID = getLeftMarker(subKmer.getLong(0));
                subKmerArray[1]= (long) getRightMarker(subKmer.getLong(0));
                kmerList.add(RowFactory.create(subKmerArray, (long) shorterID));
            }

            return kmerList.iterator();
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            return rightMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker

            return leftMarker;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }
        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    class DSBinaryMixedFixingKmerToString implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> reflexivKmerStringList = new ArrayList<Row>();
        int FixedKmerSize=31;
        long[] combinedArray;
        long[] subKmerArray = new long[1];

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {
            while (sIterator.hasNext()) {
                String subKmer = "";
                String extension ="";
                Row s = sIterator.next();

                subKmerArray[0]=s.getLong(0);
                /*
                if (getReflexivMarker(s.getLong(1)) ==1){
                    combinedArray = combineTwoLongBlocks( subKmerArray, seq2array(s.getSeq(2)));
                }else{
                    combinedArray = combineTwoLongBlocks( seq2array(s.getSeq(2)), subKmerArray );
                }
*/
                subKmer = BinaryBlocksToString(subKmerArray);
                extension = BinaryBlocksToString(seq2array(s.getSeq(2)));

                reflexivKmerStringList.add(
                        RowFactory.create(
                                subKmer, s.getLong(1), extension)
                );
            }
            return reflexivKmerStringList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
 //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }
    }

    class DSBinaryFixingKmerToString implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> reflexivKmerStringList = new ArrayList<Row>();
        int FixedKmerSize=31;

        public Iterator<Row> call(Iterator<Row> sIterator) {
            while (sIterator.hasNext()) {
                String subKmer = "";
                Row s = sIterator.next();
                for (int i = 0; i < FixedKmerSize; i++) {
                    Long currentNucleotideBinary = s.getLong(0) >>> 2 * (FixedKmerSize - i);
                    currentNucleotideBinary &= 3L;
                    char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                    subKmer += currentNucleotide;
                }

                reflexivKmerStringList.add(
                        RowFactory.create(
                                subKmer, s.getLong(1) )
                );
            }
            return reflexivKmerStringList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    class TagRowContigRDDID implements FlatMapFunction<Tuple2<Row, Long>, String>, Serializable {

        List<String> contigList = new ArrayList<String>();

        public Iterator<String> call(Tuple2<Row, Long> s) {

            contigList = new ArrayList<String>();

            String contig = BinaryBlocksToString((long[])s._1().get(0));
            int length = contig.length();
            if (length >= param.minContig) {
                String ID = ">Contig-" + length + "-" + s._2();
                String formatedContig = changeLine(contig, length, 10000000);
                contigList.add(ID + "\n" + formatedContig);
            }

            return contigList.iterator();
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            //           String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);
            StringBuilder sb= new StringBuilder();
            char currentNucleotide;

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                sb.append(currentNucleotide);
            }

            return sb.toString();
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        public String changeLine(String oneLine, int lineLength, int limitedLength) {
            String blockLine = "";
            int fold = lineLength / limitedLength;
            int remainder = lineLength % limitedLength;
            if (fold == 0) {
                blockLine = oneLine;
            } else if (fold == 1 && remainder == 0) {
                blockLine = oneLine;
            } else if (fold > 1 && remainder == 0) {
                for (int i = 0; i < fold - 1; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring((fold - 1) * limitedLength);
            } else {
                for (int i = 0; i < fold; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring(fold * limitedLength);
            }

            return blockLine;
        }
    }

    class TagRowContigDSID implements FlatMapFunction<Tuple2<String, Long>, String>, Serializable {

        List<String> contigList = new ArrayList<String>();

        public Iterator<String> call(Tuple2<String, Long> s) {

            contigList = new ArrayList<String>();

            String contig = s._1();
            int length = contig.length();
            if (length >= param.minContig) {
                String ID = ">Contig-" + length + "-" + s._2();
                String formatedContig = changeLine(contig, length, 10000000);
                contigList.add(ID + "\n" + formatedContig);
            }

            return contigList.iterator();
        }

        public String changeLine(String oneLine, int lineLength, int limitedLength) {
            String blockLine = "";
            int fold = lineLength / limitedLength;
            int remainder = lineLength % limitedLength;
            if (fold == 0) {
                blockLine = oneLine;
            } else if (fold == 1 && remainder == 0) {
                blockLine = oneLine;
            } else if (fold > 1 && remainder == 0) {
                for (int i = 0; i < fold - 1; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring((fold - 1) * limitedLength);
            } else {
                for (int i = 0; i < fold; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring(fold * limitedLength);
            }

            return blockLine;
        }
    }

    class TagRowContigID implements FlatMapFunction<Tuple2<Row, Long>, String>, Serializable {

        public Iterator<String> call(Tuple2<Row, Long> s) {


            List<String> contigList = new ArrayList<String>();

            contigList.add(s._1.getString(0) + "-" + s._2 + "\n" + s._1.getString(1));

            return contigList.iterator();
        }
    }

    class TagContigID implements FlatMapFunction<Tuple2<Tuple2<String, String>, Long>, String>, Serializable {

        public Iterator<String> call(Tuple2<Tuple2<String, String>, Long> s) {


            List<String> contigList = new ArrayList<String>();

            contigList.add(s._1._1 + "-" + s._2 + "\n" + s._1._2);

            return contigList.iterator();
        }
    }

    class DSKmerToContig implements MapPartitionsFunction<Row, Row>, Serializable {

        public Iterator<Row> call(Iterator<Row> sIterator) {
            List<Row> contigList = new ArrayList<Row>();

            while (sIterator.hasNext()) {
                Row s = sIterator.next();
                if (getReflexivMarker(s.getLong(1)) == 1) {
                    String contig = s.getString(0) + s.getString(2);
                    int length = contig.length();
                    if (length >= param.minContig) {
                        String ID = ">Contig-" + length + "-" + getLeftMarker(s.getLong(1)) + "-" + getRightMarker(s.getLong(1));
                        String formatedContig = changeLine(contig, length, 10000000);
                        contigList.add(RowFactory.create(ID, formatedContig));
                    }
                } else { // (randomReflexivMarker == 2) {
                    String contig = s.getString(2) + s.getString(0);
                    int length = contig.length();
                    if (length >= param.minContig) {
                        String ID = ">Contig-" + length +  "-" + getLeftMarker(s.getLong(1)) + "-" + getRightMarker(s.getLong(1));
                        String formatedContig = changeLine(contig, length, 10000000);
                        contigList.add(RowFactory.create(ID, formatedContig));
                    }
                }
            }

            return contigList.iterator();
        }

        public String changeLine(String oneLine, int lineLength, int limitedLength) {
            String blockLine = "";
            int fold = lineLength / limitedLength;
            int remainder = lineLength % limitedLength;
            if (fold == 0) {
                blockLine = oneLine;
            } else if (fold == 1 && remainder == 0) {
                blockLine = oneLine;
            } else if (fold > 1 && remainder == 0) {
                for (int i = 0; i < fold - 1; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring((fold - 1) * limitedLength);
            } else {
                for (int i = 0; i < fold; i++) {
                    blockLine += oneLine.substring(i * limitedLength, (i + 1) * limitedLength) + "\n";
                }
                blockLine += oneLine.substring(fold * limitedLength);
            }

            return blockLine;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

    }


    class DSLowCoverageSubKmerExtraction implements  MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> subKmerProb = new ArrayList<Row>();
        int randomReflexivMarker =1;
        //long maxSubKmerBinary = ~((~0L) << 2*param.subKmerSize);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);
        long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide
        int contigIndex = 0;
        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);

        public Iterator<Row> call (Iterator<Row> sIterator){

            while(sIterator.hasNext()){
                Row s = sIterator.next();
                contigIndex++;

                int contigLength = param.subKmerSize + (s.getSeq(2).length()-1) * 31;
                int firstSuffixLength = Long.SIZE/2 - (Long.numberOfLeadingZeros((Long)s.getSeq(2).apply(0))/2 + 1);
                contigLength += firstSuffixLength;

                if (contigLength <61) continue;

                if (s.getInt(3)>=-5 && s.getInt(3)<0){
                    if (s.getInt(1) == 1){
                        Long[] subKmerBinary = new Long[s.getSeq(0).length()];
                        for (int i=0 ; i<s.getSeq(0).length(); i++) {
                            subKmerBinary[i] = (Long) s.getSeq(0).apply(i);
                        }
                        int marker = (contigIndex | (1<<31));  // 1 as right extendable
                        subKmerProb.add(
                                RowFactory.create(subKmerBinary, marker)
                        );
                    }else{
                        randomReflexivMarker =1;
                        Row newS = singleKmerRandomizer(s);
                        Long[] subKmerBinary = new Long[((Long[]) newS.get(0)).length];
                        for (int i=0 ; i<((Long[]) newS.get(0)).length; i++) {
                            subKmerBinary[i] = ((Long[]) newS.get(0))[i];
                        }
                        int marker = (contigIndex| (1<<31));  // 1 as right extendable
                        subKmerProb.add(
                                RowFactory.create(subKmerBinary, marker)
                        );
                    }
                }

                if (s.getInt(4)>=-5 && s.getInt(4)<0){
                    if (s.getInt(1) == 1){
                        randomReflexivMarker =2;
                        Row newS = singleKmerRandomizer(s);
                        Long[] subKmerBinary = new Long[((Long[]) newS.get(0)).length];
                        for (int i=0 ; i<((Long[]) newS.get(0)).length; i++) {
                            subKmerBinary[i] = ((Long[]) newS.get(0))[i];
                        }
                        int marker = contigIndex ; // 0 as left extendable
                        subKmerProb.add(
                                RowFactory.create(subKmerBinary, marker)
                        );
                    }else {
                        Long[] subKmerBinary = new Long[s.getSeq(0).length()];
                        for (int i=0 ; i<s.getSeq(0).length(); i++) {
                            subKmerBinary[i] = (Long) s.getSeq(0).apply(i);
                        }
                        int marker = contigIndex ; // 0 as left extendable
                        subKmerProb.add(
                                RowFactory.create(subKmerBinary, marker)
                        );
                    }
                }

            }
/*
            int maxMarkerBinary =  ~((~0) << 31);
            for (int i=0; i<subKmerProb.size(); i++){
                long subKmerBinary = subKmerProb.get(i).getLong(0);
                int marker = subKmerProb.get(i).getInt(1);

                System.out.print("extracted probs: ");

                for (int j = 31; j>=0; j--){
                    long a = subKmerBinary >>> 2 *j;
                    a &= 3L;
                    char b = BinaryToNucleotide(a);
                    System.out.print(b);
                }

                int direction = marker >>> 31;
                int contigID = marker & maxMarkerBinary;
                System.out.println(" " + direction + " " + contigID);
            }
*/
            return subKmerProb.iterator();
        }

        public Row singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }


                    return RowFactory.create(newReflexivSubKmer,
                                    randomReflexivMarker, newReflexivLongArray, currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            );

                } else {


                    return currentSubKmer;
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {

                    return currentSubKmer;
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

                    return
                            RowFactory.create(newReflexivSubKmer,
                                    randomReflexivMarker, newReflexivLongArray, currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            );
                }

            }
        }


        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

    }

    class DSLowCoverageReadDetection implements MapPartitionsFunction<String, Row>, Serializable{
        long maxSubKmerBits= ~((~0L) << (2*param.subKmerSize));
        int maxContigIndexBits = ~((~0) << 31);
        Hashtable<List<Long>, Integer> probTable;

        List<Row> fragmentList = new ArrayList<Row>();
        int readLength;
        String[] units;
        String read;
        char nucleotide;
        long nucleotideInt;
        long nucleotideIntComplement;

        public DSLowCoverageReadDetection(Broadcast<Hashtable<List<Long>, Integer>> s){
            probTable = s.value();
        }

        public Iterator<Row> call(Iterator<String> s){

            while (s.hasNext()) {
                units = s.next().split("\\n");
                read = units[1];
                String RCread = reverseComplement(read);

                readLength = read.length();

                if (readLength - param.subKmerSize<= 1) {
                    continue;
                }

                Long nucleotideBinary = 0L;
                Long nucleotideBinaryReverseComplement = 0L;


                int probedContigID =-1;
                int probedLeftIndex =-1;
                int probedRightIndex = -1;

                for (int i = 0; i < readLength; i++) {
                    nucleotide = read.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);
                    // forward kmer in bits
                    nucleotideBinary <<= 2;
                    nucleotideBinary |= nucleotideInt;
                    if (i >= param.subKmerSize) {
                        nucleotideBinary &= maxSubKmerBits;
                    }

                    // reach the first complete K-mer
                    if (i >= param.subKmerSize - 1) {
                        if (probTable.containsKey(nucleotideBinary)){
                            int marker = (probTable.get(nucleotideBinary)& maxContigIndexBits);
                            int direction = ((probTable.get(nucleotideBinary) >>> 31) & 1);
/*
                            System.out.print("find a match: ");

                            for (int j=param.subKmerSize-1; j>=0; j--){
                                long a = nucleotideBinary  >>> 2 *j;
                                a &= 3L;
                                char b = BinaryToNucleotide(a);
                                System.out.print(b);
                            }

                            System.out.println(" " + marker + " " + direction);
*/
                            if (direction == 0) { // left extendable
                                if (probedLeftIndex == -1) {
                                    probedContigID = marker;
                                    probedLeftIndex = i;
                                }else{ // != -1 anthor left extendable, usually not possible
                                    continue;
                                }
                            }else if (direction == 1){ // right extendable
                                if (probedRightIndex == -1){
                                    if (probedContigID == marker ){
                                        continue;
                                    } else{
                                        probedRightIndex =i;
                                    }
                                }else { // != 1 anther right extendable, usually not possible
                                    if (probedContigID == marker ){
                                        continue;
                                    } else{
                                        probedRightIndex =i;
                                    }
                                }
                            }
                        }
                    }
                }

                if (probedLeftIndex >=0 && probedRightIndex >=0 && probedLeftIndex < probedRightIndex){
                    String lowCoverageFragment = read.substring(probedLeftIndex-param.subKmerSize+1, probedRightIndex+1);
                    System.out.println("forward: " + lowCoverageFragment);
                    fragmentList.add(
                            reflexivKmerExtractionFromLowCoverageFragment(lowCoverageFragment)
                    );
                }

                probedLeftIndex =-1;
                probedRightIndex =-1;
                probedContigID =-1;

                for (int i = 0; i < readLength; i++) {
                    nucleotide = RCread.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);
                    // forward kmer in bits
                    nucleotideBinaryReverseComplement <<= 2;
                    nucleotideBinaryReverseComplement |= nucleotideInt;
                    if (i >= param.subKmerSize) {
                        nucleotideBinaryReverseComplement &= maxSubKmerBits;
                    }

                    // reach the first complete K-mer
                    if (i >= param.subKmerSize - 1) {
                        if (probTable.containsKey(nucleotideBinaryReverseComplement)){
                            int marker = (probTable.get(nucleotideBinaryReverseComplement) & maxContigIndexBits);
                            int direction = ((probTable.get(nucleotideBinaryReverseComplement) >>> 31) & 1);
/*
                            System.out.print("find a RC match: ");

                            for (int j=param.subKmerSize-1; j>=0; j--){
                                long a = nucleotideBinaryReverseComplement  >>> 2 *j;
                                a &= 3L;
                                char b = BinaryToNucleotide(a);
                                System.out.print(b);
                            }

                            System.out.println(" " + marker + " " + direction);
*/
                            if (direction == 0) { // left extendable
                                if (probedLeftIndex == -1) {
                                    probedContigID = marker ;
                                    probedLeftIndex = i;
                                }else{ // != -1 anthor left extendable, usually not possible
                                    continue;
                                }
                            }else if (direction == 1){ // right extendable
                                if (probedRightIndex == -1){
                                    if (probedContigID == marker ){
                                        continue;
                                    } else{
                                        probedRightIndex =i;
                                    }
                                }else { // != 1 anther right extendable, usually not possible
                                    if (probedContigID == marker ){
                                        continue;
                                    } else{
                                        probedRightIndex =i;
                                    }
                                }
                            }
                        }
                    }
                }

                if (probedLeftIndex >=0 && probedRightIndex >=0 && probedLeftIndex < probedRightIndex){
                    String lowCoverageRCFragment = RCread.substring(probedLeftIndex-param.subKmerSize+1, probedRightIndex+1);
                    System.out.println("RC: " + lowCoverageRCFragment);
                    fragmentList.add(
                            reflexivKmerExtractionFromLowCoverageFragment(lowCoverageRCFragment)
                    );
                }

            }
            return fragmentList.iterator();
        }

        private String reverseComplement(String forward){
            String reverseComplementNucleotides;


            char[] nucleotides = forward.toCharArray();
            int nucleotideNum = nucleotides.length;
            char[] nucleotidesRC = new char[nucleotideNum];

            for (int i=0; i<nucleotideNum; i++){
                nucleotidesRC[nucleotideNum-i-1] = complementary(nucleotides[i]);
            }

            reverseComplementNucleotides = new String(nucleotidesRC);
            return reverseComplementNucleotides;
        }

        private char complementary (char a){
            if (a == 'A' || a == 'a'){
                return 'T';
            }else if (a == 'T' || a == 't' || a == 'U' || a == 'u'){
                return 'A';
            }else if (a == 'C' || a == 'c'){
                return 'G';
            }else if (a == 'G' || a == 'g'){
                return 'C';
            }else {
                return 'N';
            }
        }

        private Row reflexivKmerExtractionFromLowCoverageFragment(String s){
            int remain = s.length() - param.subKmerSize;
            long nucleotideBinary=0L;
            long[] remainNucleotidesArray = new long[remain/31+1];
            int firstBlock = remain % 31;
            long maxFirstBlockBinary = ~((~0L) << (2 * firstBlock));
            char nucleotideNT;
            long nucleotideNTInt;

            for (int i = 0; i < param.subKmerSize; i++){
                nucleotideNT = s.charAt(i);
                if (nucleotideNT >= 256) nucleotideNT = 255;
                nucleotideNTInt = nucleotideValue(nucleotideNT);
                // forward kmer in bits
                nucleotideBinary <<= 2;
                nucleotideBinary |= nucleotideNTInt;
            }

            for (int i = param.subKmerSize; i < s.length(); i++){
                nucleotideNT = s.charAt(i);
                if (nucleotideNT >= 256) nucleotideNT = 255;
                nucleotideNTInt = nucleotideValue(nucleotideNT);

                if (i-param.subKmerSize - firstBlock >=0) {
                    remainNucleotidesArray[((i - param.subKmerSize - firstBlock) / 31)+1] <<= 2;
                    remainNucleotidesArray[((i - param.subKmerSize - firstBlock) / 31)+1] |= nucleotideNTInt;
                }else {
                    remainNucleotidesArray[0] <<=2;
                    remainNucleotidesArray[0] |= nucleotideNTInt;
                }

                if (i-param.subKmerSize == firstBlock-1){
                    remainNucleotidesArray[0] &= maxFirstBlockBinary;
                    remainNucleotidesArray[0] |= (1L << 2*firstBlock); // add C markers in front
                }
            }
/*
            System.out.print("binarized: ");

            for (int i=param.subKmerSize-1; i>=0; i--){
                long a = nucleotideBinary  >>> 2 *i;
                a &= 3L;
                char b = BinaryToNucleotide(a);
                System.out.print(b);
            }

            for (int i=firstBlock-1; i>=0; i--){
                long a = remainNucleotidesArray[0]  >>> 2 *i;
                a &= 3L;
                char b = BinaryToNucleotide(a);
                System.out.print(b);
            }

            for (int i=30; i>=0; i--){
                long a = remainNucleotidesArray[1]  >>> 2 *i;
                a &= 3L;
                char b = BinaryToNucleotide(a);
                System.out.print(b);
            }

            System.out.println();
*/
            return RowFactory.create(nucleotideBinary,
                    1, remainNucleotidesArray, -10000000, -10000000
            );
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }


        private long nucleotideValue(char a) {
            long value;
            if (a == 'A') {
                value = 0L;
            } else if (a == 'C') {
                value = 1L;
            } else if (a == 'G') {
                value = 2L;
            } else { // T
                value = 3L;
            }
            return value;
        }
    }


    /**
     * interface class for RDD implementation, used in step 5
     */

    class DSBinaryReflexivKmerToString implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> reflexivKmerStringList = new ArrayList<Row>();

        public Iterator<Row> call(Iterator<Row> sIterator) {
            while (sIterator.hasNext()) {
                String subKmer = "";
                String subString = "";
                Row s = sIterator.next();
                int currentSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros(s.getLong(2)) / 2 + 1);
                for (int i = 1; i <= param.subKmerSize; i++) {
                    Long currentNucleotideBinary = s.getLong(0) >>> 2 * (param.subKmerSize - i);
                    currentNucleotideBinary &= 3L;
                    char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                    subKmer += currentNucleotide;
                }

                for (int i = 1; i <= currentSuffixLength; i++) {
                    Long currentNucleotideBinary = s.getLong(2) >>> 2 * (currentSuffixLength - i);
                    currentNucleotideBinary &= 3L;
                    char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                    subString += currentNucleotide;
                }

                reflexivKmerStringList.add(
                        RowFactory.create(
                                subKmer, s.getInt(1), subString, s.getInt(3), s.getInt(4))
                );
            }
            return reflexivKmerStringList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    /**
     *
     */
    class DSBinaryReflexivKmerArrayToString implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> reflexivKmerStringList = new ArrayList<Row>();

        public Iterator<Row> call(Iterator<Row> sIterator) {
            while (sIterator.hasNext()) {
                String subKmer = "";
                String subString = "";
                Row s = sIterator.next();
                subKmer =  BinaryBlocksToString(seq2array(s.getSeq(0)));
                subString = BinaryBlocksToString(seq2array(s.getSeq(2)));

                //int length = subKmer.length() + subString.length();
              //  System.out.println("Length: " + length + " " + getLeftMarker(s.getLong(1)) + " " + getRightMarker(s.getLong(1)));

                reflexivKmerStringList.add(
                        RowFactory.create(subKmer,
                                s.getLong(1), subString
                        )
                );

            }
            return reflexivKmerStringList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }
        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }


    }

    /**
     *
     */
    class DSgetFixingLongKmer implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList=new ArrayList<Row>();
        int FixedKmerSize = 31;
        long[] subKmer;
        long[] extension;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception{
            while (sIterator.hasNext()){
                Row fullKmer = sIterator.next();

                long[] fullKmerArray = seq2array(fullKmer.getSeq(0));

                int length = currentKmerSizeFromBinaryBlockArray(fullKmerArray);

                if (length!=FixedKmerSize){
                    subKmer = leftShiftOutFromArray(fullKmerArray, FixedKmerSize-1);
                    extension = leftShiftArray(fullKmerArray, FixedKmerSize-1);
                    kmerList.add(RowFactory.create(subKmer[0],fullKmer.getLong(1), extension));
                }
            }
            return kmerList.iterator();
        }

        private long[] reverseBinaryBlocks(long[] blocks){
            int length = currentKmerSizeFromBinaryBlockArray(blocks);
            int blockNumber= blocks.length;
            long[] newBlocks= new long[blockNumber];
            int reverseIndex;
            int reverseBlockIndex;
            int relativeReverseIndex;

            int forwardBlockIndex;

            long twoBits;
            for (int i=0; i<length;i++){
                reverseIndex=length-i-1;
                reverseBlockIndex=reverseIndex/31;
                relativeReverseIndex=reverseIndex%31;

                forwardBlockIndex=i/31;

                twoBits=blocks[reverseBlockIndex] >>>2*(31-relativeReverseIndex);
                twoBits&=3L;

                newBlocks[forwardBlockIndex]|=twoBits;
                newBlocks[forwardBlockIndex] <<=2;
            }
            int lastBlockShift=31-(length-1)%31-1;
            newBlocks[newBlocks.length-1] <<=2*lastBlockShift;
            newBlocks[newBlocks.length - 1] |= (1L << 2 * (lastBlockShift));

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                //    String rightBlocksString = BinaryBlocksToString(rightBlocks);
                //    String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //       String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            if (aLength>bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                //        String longer = BinaryBlocksToString(shorterVersion);
                //        String shorter = BinaryBlocksToString(arrayB);
                // System.out.println("longer: " + longer + " shorter: " + shorter);
                // if (shorterVersion.length>=2 && arrayB.length >=2) {
                //    System.out.println("longer array: " + shorterVersion[0] + " "  + shorterVersion[1] + " shorter array: " + arrayB[0] + " " + arrayB[1]);
                //}
                if (Arrays.equals(shorterVersion, arrayB)){
                    //  if (shorterVersion.length>=2){
                    //        System.out.println("marker!!!");
                    // }
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

    }

    class DSgetFixingKmer implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList=new ArrayList<Row>();
        int FixedKmerSize = 31;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception{
            while (sIterator.hasNext()){
                Row fullKmer = sIterator.next();

                int length = currentKmerSizeFromBinaryBlockArray(seq2array(fullKmer.getSeq(0)));

                if (length==FixedKmerSize){
                    kmerList.add(
                            RowFactory.create(
                                    seq2array(fullKmer.getSeq(0))[0], 1));
                }
            }
            return kmerList.iterator();
        }

        private long[] reverseBinaryBlocks(long[] blocks){
            int length = currentKmerSizeFromBinaryBlockArray(blocks);
            int blockNumber= blocks.length;
            long[] newBlocks= new long[blockNumber];
            int reverseIndex;
            int reverseBlockIndex;
            int relativeReverseIndex;

            int forwardBlockIndex;

            long twoBits;
            for (int i=0; i<length;i++){
                reverseIndex=length-i-1;
                reverseBlockIndex=reverseIndex/31;
                relativeReverseIndex=reverseIndex%31;

                forwardBlockIndex=i/31;

                twoBits=blocks[reverseBlockIndex] >>>2*(31-relativeReverseIndex);
                twoBits&=3L;

                newBlocks[forwardBlockIndex]|=twoBits;
                newBlocks[forwardBlockIndex] <<=2;
            }
            int lastBlockShift=31-(length-1)%31-1;
            newBlocks[newBlocks.length-1] <<=2*lastBlockShift;
            newBlocks[newBlocks.length - 1] |= (1L << 2 * (lastBlockShift));

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                //    String rightBlocksString = BinaryBlocksToString(rightBlocks);
                //    String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //       String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            if (aLength>bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                //        String longer = BinaryBlocksToString(shorterVersion);
                //        String shorter = BinaryBlocksToString(arrayB);
                // System.out.println("longer: " + longer + " shorter: " + shorter);
                // if (shorterVersion.length>=2 && arrayB.length >=2) {
                //    System.out.println("longer array: " + shorterVersion[0] + " "  + shorterVersion[1] + " shorter array: " + arrayB[0] + " " + arrayB[1]);
                //}
                if (Arrays.equals(shorterVersion, arrayB)){
                    //  if (shorterVersion.length>=2){
                    //        System.out.println("marker!!!");
                    // }
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

    }

    class DSExtractFixingKmerFromContigEnds implements MapPartitionsFunction<Row, Row>, Serializable{

        List<Row> kmerList= new ArrayList<Row>();
        long[] fullKmerArray;
        int FixedKmerSize = 31;

        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception{
            while (sIterator.hasNext()){
                Row subKmer = sIterator.next();

                if (getReflexivMarker(subKmer.getLong(1))==1) {
                    fullKmerArray = combineTwoLongBlocks(seq2array(subKmer.getSeq(0)), seq2array(subKmer.getSeq(2)));
                }else{
                    fullKmerArray = combineTwoLongBlocks(seq2array(subKmer.getSeq(2)),seq2array(subKmer.getSeq(0)));
                }
                int length = currentKmerSizeFromBinaryBlockArray(fullKmerArray);

                if (length >= 2* param.maxKmerSize){
                    long[] fixedKmerLeft;
                    long[] fixedKmerRight;

                    for (int i=0;i<param.maxKmerSize-FixedKmerSize+1; i++){
                        // xxxxxxxxxxx---------
                        // xxxx
                        //  xxxx
                        //   xxxx
                        fixedKmerLeft = leftShiftOutFromArray(fullKmerArray,i+FixedKmerSize);
                        fixedKmerLeft=leftShiftArray(fixedKmerLeft, i);
                        long attribute = buildingAlongFromThreeInt(1, -1, -1);
                        kmerList.add(RowFactory.create(fixedKmerLeft,attribute));

                        // ---------xxxxxxxxxxx
                        //                 xxxx
                        //                xxxx
                        //               xxxx

                        fixedKmerRight= leftShiftArray(fullKmerArray, length-i-FixedKmerSize);
                        fixedKmerRight= leftShiftOutFromArray(fixedKmerRight, FixedKmerSize);
                        kmerList.add(RowFactory.create(fixedKmerRight,attribute));
                    }


                    long[] cuttedKmer= leftShiftArray(fullKmerArray, param.maxKmerSize-FixedKmerSize+1);
                    cuttedKmer = leftShiftOutFromArray(cuttedKmer, length-2*(param.maxKmerSize-FixedKmerSize+1));

                    long attribute2=onlyChangeReflexivMarker(subKmer.getLong(1), 1);
                    if (getLeftMarker(subKmer.getLong(1)) >0 && getRightMarker(subKmer.getLong(1)) >0){
                        attribute2 = buildingAlongFromThreeInt(1, 3+param.maxKmerSize, 3+param.maxKmerSize);
                    }else if (getLeftMarker(subKmer.getLong(1)) >0 ){
                        attribute2 = buildingAlongFromThreeInt(1, 3+param.maxKmerSize, getRightMarker(subKmer.getLong(1)));
                    }else if (getRightMarker(subKmer.getLong(1)) >0) {
                        attribute2 = buildingAlongFromThreeInt(1, getLeftMarker(subKmer.getLong(1)), +3+param.maxKmerSize);
                    }

//                    long attribute2 = buildingAlongFromThreeInt(1, -1, -1);
                    kmerList.add(RowFactory.create(cuttedKmer, attribute2, subKmer.getLong(1)));
                }

            }

            return kmerList.iterator();
        }
        private long[] reverseBinaryBlocks(long[] blocks){
            int length = currentKmerSizeFromBinaryBlockArray(blocks);
            int blockNumber= blocks.length;
            long[] newBlocks= new long[blockNumber];
            int reverseIndex;
            int reverseBlockIndex;
            int relativeReverseIndex;

            int forwardBlockIndex;

            long twoBits;
            for (int i=0; i<length;i++){
                reverseIndex=length-i-1;
                reverseBlockIndex=reverseIndex/31;
                relativeReverseIndex=reverseIndex%31;

                forwardBlockIndex=i/31;

                twoBits=blocks[reverseBlockIndex] >>>2*(31-relativeReverseIndex);
                twoBits&=3L;

                newBlocks[forwardBlockIndex]|=twoBits;
                newBlocks[forwardBlockIndex] <<=2;
            }
            int lastBlockShift=31-(length-1)%31-1;
            newBlocks[newBlocks.length-1] <<=2*lastBlockShift;
            newBlocks[newBlocks.length - 1] |= (1L << 2 * (lastBlockShift));

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                //    String rightBlocksString = BinaryBlocksToString(rightBlocks);
                //    String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //       String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            if (aLength>bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                //        String longer = BinaryBlocksToString(shorterVersion);
                //        String shorter = BinaryBlocksToString(arrayB);
                // System.out.println("longer: " + longer + " shorter: " + shorter);
                // if (shorterVersion.length>=2 && arrayB.length >=2) {
                //    System.out.println("longer array: " + shorterVersion[0] + " "  + shorterVersion[1] + " shorter array: " + arrayB[0] + " " + arrayB[1]);
                //}
                if (Arrays.equals(shorterVersion, arrayB)){
                    //  if (shorterVersion.length>=2){
                    //        System.out.println("marker!!!");
                    // }
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0) {
                nucleotide = 'A';
            } else if (twoBits == 1) {
                nucleotide = 'C';
            } else if (twoBits == 2) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

    }

    class DSFilterRepeatLowCoverageFragment implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            randomReflexivMarker=1; // in this class, randomReflexivMarker is constantly set to 1

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(0).getSeq(0))){
                            continue;
                        }else{
                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(0));
                            resetSubKmerGroup(s);
                        }
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop

            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                }
            }

      //      int kmernumber = reflexivKmerConcatList.size();
       //     System.out.println("Double afterwards extendable number: " + kmernumber);
            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSReflexivAndForwardKmer implements MapPartitionsFunction<Row, Row>, Serializable {

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;




        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

                reflexivKmerConcatList.add(s); // forward or reflected kmer
                if (s.getInt(1)==1) {
                    randomReflexivMarker =2;
                }else{
                    randomReflexivMarker =1;
                }
                singleKmerRandomizer(s); // reflected or forward kmer

            } // while loop

            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                /* System.out.println("mark  newReflxivSubkmer Length: " + newReflexivSubKmer.length);
                                System.out.println("mark  first newReflexivBlock: " + newReflexivSubKmer[0]);
                                System.out.println("mark  second newReflexivBlock: " + newReflexivSubKmer[1]);
                                System.out.println("mark  third newReflexivBlock: " + newReflexivSubKmer[2]);
                                System.out.println("mark  blockSize: " + blockSize);
                                System.out.println("mark  currentSubKmer: " + currentSubKmer.getSeq(0).size());
                                System.out.println("mark  first currentSubKmer: " + currentSubKmer.getSeq(0).apply(0));
                                System.out.println("mark  second currentSubKmer: " + currentSubKmer.getSeq(0).apply(1));
                                System.out.println("mark  third currentSubKmer: " + currentSubKmer.getSeq(0).apply(2));
                                System.out.println("mark  param.subKmerBinaryslots: " + param.subKmerBinarySlots);
*/
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                       System.out.println(" Double random " + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq(),
                                    randomReflexivMarker,  JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                } else {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                           System.out.println(" Double random same " + randomReflexivMarker);
                           */
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.println(" Double random same " + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random " + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq() ,
                                    randomReflexivMarker, JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                }

            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    class DSFilterStillExtendableKmerEnds implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            randomReflexivMarker=1; // in this class, randomReflexivMarker is constantly set to 1

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {
                                int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(0)) / 2 + 1);
                                int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) s.getSeq(2).apply(0)) / 2 + 1);
                                int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                if (s.getInt(1) == 1) {
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        if (tmpBlockSize *31 + tmpReflexivKmerSuffixLength >=currentBlockSize *31 + currentReflexivKmerSuffixLength) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        }else{
                                            reflexivKmerConcatList.add(s);
                                        }
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        if (tmpBlockSize *31 + tmpReflexivKmerSuffixLength >=currentBlockSize *31 + currentReflexivKmerSuffixLength) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        }else{
                                            reflexivKmerConcatList.add(s);
                                        }
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        if (tmpBlockSize *31 + tmpReflexivKmerSuffixLength >=currentBlockSize *31 + currentReflexivKmerSuffixLength) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        }else{
                                            reflexivKmerConcatList.add(s);
                                        }
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        if (tmpBlockSize *31 + tmpReflexivKmerSuffixLength >=currentBlockSize *31 + currentReflexivKmerSuffixLength) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        }else{
                                            reflexivKmerConcatList.add(s);
                                        }
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop

            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                }
            }

            int kmernumber = reflexivKmerConcatList.size();
            System.out.println("Double afterwards extendable number: " + kmernumber);
            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterStillExtendableKmerFromPairs implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            randomReflexivMarker=1; // in this class, randomReflexivMarker is constantly set to 1

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {

                                if (s.getInt(1) == 1) {
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        break;
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop

            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                }
            }

            int kmernumber = reflexivKmerConcatList.size();
            System.out.println("Double afterwards extendable number: " + kmernumber);
            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterUnExtendableKmerLeftEnds implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            randomReflexivMarker=1; // in this class, randomReflexivMarker is constantly set to 1

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

                if (s.getInt(1) == 1){
                    reflexivKmerConcatList.add(s);
                } else {
                    singleKmerRandomizer(s);
                }
            }

            return reflexivKmerConcatList.iterator();
        }


        public void singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random left end " + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq(),
                                    randomReflexivMarker,  JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                } else {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random same left end" + randomReflexivMarker);
                    */
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.println(" Double random same left end" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }
/*
                    System.err.print("start ---- ");

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    System.out.print(" was den fuk left ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }


                    System.err.println(" Double random left end " + randomReflexivMarker + " " + newReflexivSubKmer.length + " " + newReflexivLongArray.length);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq() ,
                                    randomReflexivMarker, JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                }

            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterUnExtendableKmerRightEnds implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            randomReflexivMarker=2; // in this class, randomReflexivMarker is constantly set to 2

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

                if (s.getInt(1) == 2){
                    reflexivKmerConcatList.add(s);
                } else {
                    singleKmerRandomizer(s);
                }
            }

            return reflexivKmerConcatList.iterator();
        }

        public void singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }
/*
                    System.err.print(" start right ---- ");

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }


                    System.err.print(" was den fuk right ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.err.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.err.print(b);
                        }
                    }


                    System.err.println(" Double random right end " + randomReflexivMarker + " " + newReflexivSubKmer.length + " " + newReflexivLongArray.length);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq(),
                                    randomReflexivMarker,  JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                } else {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random same right end" + randomReflexivMarker);
                */
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {
/*

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.println(" Double random same right end" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random right end" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq() ,
                                    randomReflexivMarker, JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                }

            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterExtendableKmerPairs implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            randomReflexivMarker=1; // in this class, randomReflexivMarker is constantly set to 1

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {
                                if (s.getInt(1) == 1) {
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(0)) / 2 + 1);
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) s.getSeq(2).apply(0)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                        if (s.getInt(3) < 0 && tmpReflexivKmerExtendList.get(i).getInt(4) < 0) {
                                            reflexivKmerConcatList.add(s);
                                            singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(3) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(4) >= 0) {
                                            reflexivKmerConcatList.add(s);
                                            singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(3) >= 0 && s.getInt(3) - tmpBlockSize >= 0) {
                                            reflexivKmerConcatList.add(s);
                                            singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (tmpReflexivKmerExtendList.get(i).getInt(4) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(4) - currentBlockSize >= 0) {
                                            reflexivKmerConcatList.add(s);
                                            singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            resetSubKmerGroup(s);
                                            break;
                                        }
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        //directKmerComparison(s);
                                        System.out.println("mark check if this exists");
                                        resetSubKmerGroup(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        System.out.println("mark check if this exists");
                                        resetSubKmerGroup(s);
                                        //directKmerComparison(s);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(0)) / 2 + 1);
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) s.getSeq(2).apply(0)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;
                                        if (s.getInt(4) < 0 && tmpReflexivKmerExtendList.get(i).getInt(3) < 0) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                            singleKmerRandomizer(s);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(4) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(3) >= 0) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                            singleKmerRandomizer(s);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(4) >= 0 && s.getInt(4) - tmpBlockSize >= 0) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                            singleKmerRandomizer(s);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (tmpReflexivKmerExtendList.get(i).getInt(3) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(3) - currentBlockSize >= 0) {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                            singleKmerRandomizer(s);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            resetSubKmerGroup(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop

            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                }
            }

            int kmernumber = reflexivKmerConcatList.size();
            System.out.println("Double afterwards extendable number: " + kmernumber);
            return reflexivKmerConcatList.iterator();
        }

        public void singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random extendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq(),
                                    randomReflexivMarker,  JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                } else {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random same extendable pairs" + randomReflexivMarker);
                    */
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.println(" Double random same extendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random extendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq() ,
                                    randomReflexivMarker, JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                }

            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterUnExtendableKmer implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;




        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            randomReflexivMarker =1;

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {
                                if (s.getInt(1) == 1) {
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(0)) / 2 + 1);
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) s.getSeq(2).apply(0)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                        if (s.getInt(3) < 0 && tmpReflexivKmerExtendList.get(i).getInt(4) < 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(3) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(4) >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(3) >= 0 && s.getInt(3) - tmpBlockSize >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (tmpReflexivKmerExtendList.get(i).getInt(4) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(4) - currentBlockSize >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i);
                                            resetSubKmerGroup(s);
                                            break;
                                        }
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        resetSubKmerGroup(s);
                                        //directKmerComparison(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (tmpReflexivKmerExtendList.get(i).getInt(1) == 2) {
                                        //directKmerComparison(s);
                                        singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                        tmpReflexivKmerExtendList.remove(i);
                                        resetSubKmerGroup(s);
                                        break;
                                    } else if (tmpReflexivKmerExtendList.get(i).getInt(1) == 1) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(0)) / 2 + 1);
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) s.getSeq(2).apply(0)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;
                                        if (s.getInt(4) < 0 && tmpReflexivKmerExtendList.get(i).getInt(3) < 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(4) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(3) >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (s.getInt(4) >= 0 && s.getInt(4) - tmpBlockSize >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (tmpReflexivKmerExtendList.get(i).getInt(3) >= 0 && tmpReflexivKmerExtendList.get(i).getInt(3) - currentBlockSize >= 0) {
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                            tmpReflexivKmerExtendList.remove(i);
                                            resetSubKmerGroup(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);

                                reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                                tmpReflexivKmerExtendList.remove(i);
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop

            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                       reflexivKmerConcatList.add(tmpReflexivKmerExtendList.get(i));
                }
            }

            return reflexivKmerConcatList.iterator();
        }


        public void singleKmerRandomizer(Row currentSubKmer) {
            int blockSize = currentSubKmer.getSeq(2).length();

            Long[] newReflexivLongArray = new Long[blockSize];

            if (currentSubKmer.getInt(1) == 1) {
                int firstSuffixBlockLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxSuffixLengthBinary = ~((~0L) << (2 * firstSuffixBlockLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                Long newReflexivLong;

                if (randomReflexivMarker == 2) {
                    if (blockSize > 1) {

                        if (firstSuffixBlockLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots; i > 0; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i >= param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        } else { // firstSuffixBlockLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[0] = transit1;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) << 2 * (31 - param.subKmerSizeResidue));
                                }else { // (blockSize== param.subKmerBinarySlots){
                                    newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(blockSize - param.subKmerBinarySlots) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2*(31-param.subKmerSizeResidue + firstSuffixBlockLength));
                                }
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                //newReflexivSubKmer[0] = transit1;
                                //newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(blockSize-param.subKmerBinarySlots) << 2*(31-param.subKmerSizeResidue));


                                for (int i = blockSize - param.subKmerBinarySlots; i > 1; i--) {
                                    int j = param.subKmerBinarySlots + i - 1; // index of the new prefix long array
                                    newReflexivLongArray[j] = ((Long) currentSubKmer.getSeq(2).apply(i) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[j] |= (Long) currentSubKmer.getSeq(2).apply(i - 1) << 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[j] &= maxSubKmerBinary;
                                }

                                if (param.subKmerBinarySlots < blockSize) {
                                    newReflexivLongArray[param.subKmerBinarySlots] = ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary)<< 2 * (31 - param.subKmerSizeResidue);
                                    newReflexivLongArray[param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 + firstSuffixBlockLength - param.subKmerSizeResidue));
                                    newReflexivLongArray[param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                //   if (blockSize== param.subKmerBinarySlots){ // in the context of blockSize >= param.subKmerBinarySlots
                                //  newReflexivLongArray[param.subKmerBinarySlots-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivLongArray[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivLongArray[param.subKmerBinarySlots - 1] &= maxSubKmerBinary;
                                //  }

                                for (int i = param.subKmerBinarySlots - 2; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            } else { // blockSize < param.subKmerSizeResidue
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(blockSize - 1) & maxSubKmerResidueBinary);

                                long transit1 = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) >>> (2 * param.subKmerSizeResidue);
                                long transit2 = 0L;
                                for (int i = param.subKmerBinarySlots - 2; i > param.subKmerBinarySlots - blockSize; i--) {
                                    int j = blockSize - param.subKmerBinarySlots + i; // index of suffix long array
                                    transit2 = (Long) currentSubKmer.getSeq(2).apply(j) >>> (2 * param.subKmerSizeResidue);

                                    newReflexivSubKmer[i] = transit1;
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(j) << 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;

                                    transit1 = transit2;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] = (Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * param.subKmerSizeResidue;
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) << 2 * (31 - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (31 - param.subKmerSizeResidue + firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize] &= maxSubKmerBinary;

                                // newReflexivSubKmer[param.subKmerBinarySlots-blockSize-1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> (2 * param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - blockSize - 1] &= maxSubKmerBinary;

                                for (int i = param.subKmerBinarySlots - blockSize - 2; i >= 0; i--) {
                                    int j = blockSize + i; // index of the subkmer

                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - 1; i > 0; i--) {
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(i - 1) << 2 * firstSuffixBlockLength);
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - firstSuffixBlockLength);
                                newReflexivLongArray[0] |= (1L << 2 * firstSuffixBlockLength); // add C marker in the front
                            }
                        }


                    } else { // block size ==1
                        if (firstSuffixBlockLength > param.subKmerSizeResidue) { // firstSuffixBlockLength is longer than the length of the last block (element) of sub kmer long array
                            //long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * (firstSuffixBlockLength - param.subKmerSizeResidue);
                            long transitBit1 = (((Long)currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary) >>> 2 * param.subKmerSizeResidue);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            newReflexivSubKmer[param.subKmerBinarySlots - 2] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-1) << 2* (firstSuffixBlockLength-param.subKmerSizeResidue));
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) << 2*firstSuffixBlockLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 2] &= maxSubKmerBinary;
                            transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-2) >>> 2 * (31 - firstSuffixBlockLength);

                            for (int i = param.subKmerBinarySlots - 3; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = ((Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength);
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit1;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else if (firstSuffixBlockLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = ((Long) currentSubKmer.getSeq(2).apply(0) & maxSubKmerResidueBinary);

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength);
                            newReflexivLongArray[0] = newReflexivLong;

                        } else { //firstSuffixBlockLength < param.subKmerSizeResidue
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * (param.subKmerSizeResidue - firstSuffixBlockLength);
                            long transitBit2 = 0L;

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) << 2 * firstSuffixBlockLength;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(0) & maxSuffixLengthBinary);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            for (int i = param.subKmerBinarySlots - 2; i >= 0; i--) {
                                transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * (31 - firstSuffixBlockLength);

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) << 2 * firstSuffixBlockLength;
                                newReflexivSubKmer[i] |= transitBit1;
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivLong = transitBit2;
                            newReflexivLong |= (1L << 2 * firstSuffixBlockLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random unextendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq(),
                                    randomReflexivMarker,  JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                } else {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random same unextendable pairs" + randomReflexivMarker);
                    */
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer.getInt(1) == 2 */
                int firstPrefixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros((Long) currentSubKmer.getSeq(2).apply(0)) / 2 + 1);
                long maxPrefixLengthBinary = ~((~0L) << (2 * firstPrefixLength));
                Long[] newReflexivSubKmer = new Long[param.subKmerBinarySlots];
                long newReflexivLong = 0L;


                if (randomReflexivMarker == 2) {

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(0)>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(0).apply(1)>>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (currentSubKmer.getSeq(0).length() >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(2)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (currentSubKmer.getSeq(0).length() >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(0).apply(3)>>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = (Long)currentSubKmer.getSeq(2).apply(0) >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(1) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(2) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = (Long)currentSubKmer.getSeq(2).apply(3) >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.println(" Double random same unextendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */
                    if (blockSize > 1) {
                        if (firstPrefixLength >= param.subKmerSizeResidue) {
                            if (blockSize >= param.subKmerBinarySlots) {
                                for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * param.subKmerSizeResidue;
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue));
                                } else {
                                    newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength); // add C marker in the front

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;

                            } else { // blockSize < param.subKmerBinarySlots
                                for (int i = 0; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) >>> 2 * (firstPrefixLength - param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[0] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize - 1 + i;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        } else { // firstPrefixLength < param.subKmerSizeResidue
                            if (blockSize >= param.subKmerBinarySlots) {
                                newReflexivSubKmer[0] =((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;

                                for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                }
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(2).apply(param.subKmerBinarySlots) >>> 2 * (31 - param.subKmerSizeResidue);
                                } else { // blockSize == param.subKmerBinarySlots
                                    newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue);
                                }
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - param.subKmerBinarySlots; i++) {
                                    int j = param.subKmerBinarySlots + i - 1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(2).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(2).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                if (blockSize > param.subKmerBinarySlots) {
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[blockSize - param.subKmerBinarySlots] &= maxSubKmerBinary;
                                }

                                for (int i = blockSize - param.subKmerBinarySlots + 1; i < blockSize - 1; i++) {
                                    int j = i - blockSize + param.subKmerBinarySlots - 1; // index of subKmer
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;


                            } else { // blockSize < param.subKmerBinarySlots
                                newReflexivSubKmer[0] = ( (Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[0] |= ((Long) currentSubKmer.getSeq(2).apply(1) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[0] &= maxSubKmerBinary;
                                for (int i = 1; i < blockSize - 1; i++) {
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(2).apply(i) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |=( (Long) currentSubKmer.getSeq(2).apply(i + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                newReflexivSubKmer[blockSize - 1] = (Long) currentSubKmer.getSeq(2).apply(blockSize - 1) << 2 * (31 - firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] |= ((Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength);
                                newReflexivSubKmer[blockSize - 1] &= maxSubKmerBinary;

                                for (int i = blockSize; i < param.subKmerBinarySlots - 1; i++) {
                                    int j = i - blockSize; // index of subKmer
                                    newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * (31 - firstPrefixLength);
                                    newReflexivSubKmer[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * firstPrefixLength);
                                    newReflexivSubKmer[i] &= maxSubKmerBinary;
                                }

                                // newReflexivSubKmer[param.subKmerBinarySlots-1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize-1) >>> 2*(firstPrefixLength-param.subKmerSizeResidue);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize - 1) << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue + firstPrefixLength));
                                newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                                // newReflexivLongArray[0] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots-blockSize) << 2*param.subKmerSizeResidue;
                                newReflexivLongArray[0] = ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - blockSize) >>> 2 * (31 - param.subKmerSizeResidue));
                                newReflexivLongArray[0] &= maxPrefixLengthBinary;
                                newReflexivLongArray[0] |= (1L << 2 * firstPrefixLength);

                                for (int i = 1; i < blockSize - 1; i++) {
                                    int j = param.subKmerBinarySlots - blockSize + i -1;
                                    newReflexivLongArray[i] = (Long) currentSubKmer.getSeq(0).apply(j) << 2 * param.subKmerSizeResidue;
                                    newReflexivLongArray[i] |= ((Long) currentSubKmer.getSeq(0).apply(j + 1) >>> 2 * (31 - param.subKmerSizeResidue));
                                    newReflexivLongArray[i] &= maxSubKmerBinary;
                                }

                                newReflexivLongArray[blockSize - 1] = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 2) << 2 * param.subKmerSizeResidue;
                                newReflexivLongArray[blockSize - 1] |= (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                                newReflexivLongArray[blockSize - 1] &= maxSubKmerBinary;
                            }
                        }

                    } else { /* blockSize == 1*/
                        if (firstPrefixLength > param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 >>> 2*(firstPrefixLength- param.subKmerSizeResidue);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (transitBit1 << 2 * param.subKmerSizeResidue);
                            newReflexivLong &= maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker in the front

                            newReflexivLongArray[0] = newReflexivLong;
                        } else if (firstPrefixLength == param.subKmerSizeResidue) {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1;
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;

                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1);
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker

                            newReflexivLongArray[0] = newReflexivLong;
                        } else {
                            long transitBit1 = (Long) currentSubKmer.getSeq(0).apply(0) & maxPrefixLengthBinary;

                            newReflexivSubKmer[0] = (Long) currentSubKmer.getSeq(0).apply(0) >>> 2 * firstPrefixLength;
                            newReflexivSubKmer[0] |= (((Long) currentSubKmer.getSeq(2).apply(0) & maxPrefixLengthBinary) << 2 * (31 - firstPrefixLength));
                            newReflexivSubKmer[0] &= maxSubKmerBinary;

                            for (int i = 1; i < param.subKmerBinarySlots - 1; i++) {
                                long transitBit2 = (Long) currentSubKmer.getSeq(0).apply(i) & maxPrefixLengthBinary;

                                newReflexivSubKmer[i] = (Long) currentSubKmer.getSeq(0).apply(i) >>> 2 * firstPrefixLength;
                                newReflexivSubKmer[i] |= (transitBit1 << 2 * (31 - firstPrefixLength));
                                newReflexivSubKmer[i] &= maxSubKmerBinary;

                                transitBit1 = transitBit2;
                            }

                            newReflexivSubKmer[param.subKmerBinarySlots - 1] = transitBit1 << 2 * (param.subKmerSizeResidue - firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] |= ((Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) >>> 2 * firstPrefixLength);
                            newReflexivSubKmer[param.subKmerBinarySlots - 1] &= maxSubKmerResidueBinary;


                            newReflexivLong = (Long) currentSubKmer.getSeq(0).apply(param.subKmerBinarySlots - 1) & maxPrefixLengthBinary;
                            newReflexivLong |= (1L << 2 * firstPrefixLength); // add C marker
                            newReflexivLongArray[0] = newReflexivLong;
                        }
                    }

/*
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[0] >> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivSubKmer[1] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivSubKmer.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivSubKmer[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivSubKmer.length >=4){
                        for (int k = 16; k >= 0; k--) {
                            long a = newReflexivSubKmer[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    System.out.print(" ");
                    for (int k = 30; k >= 0; k--) {
                        long a = newReflexivLongArray[0] >>> 2 * k;
                        a &= 3L;
                        char b = BinaryToNucleotide(a);
                        System.out.print(b);
                    }

                    if (newReflexivLongArray.length >=2){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[1] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=3){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[2] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }

                    if (newReflexivLongArray.length >=4){
                        for (int k = 30; k >= 0; k--) {
                            long a = newReflexivLongArray[3] >>> 2 * k;
                            a &= 3L;
                            char b = BinaryToNucleotide(a);
                            System.out.print(b);
                        }
                    }


                    System.out.println(" Double random unextendable pairs" + randomReflexivMarker);
*/
                    reflexivKmerConcatList.add(
                            RowFactory.create(JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivSubKmer).iterator()).asScala().toSeq() ,
                                    randomReflexivMarker, JavaConverters.asScalaIteratorConverter(Arrays.asList(newReflexivLongArray).iterator()).asScala().toSeq(), currentSubKmer.getInt(3), currentSubKmer.getInt(4)
                            )
                    );
                }

            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }


        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }


        private boolean subKmerSlotComparator(Seq a, Seq b) {
            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSChangingFixingKmerToReflectedKmer implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList= new ArrayList<Row>();
        long attribute;
        long[] subKmerArray=new long[1];
        long[] extension;
        int FixingKmerSize=31;
        long[] combinedArray;
        int length;

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while (s.hasNext()){
                Row subKmer=s.next();

                subKmerArray[0]=subKmer.getLong(0);
                if (getReflexivMarker(subKmer.getLong(1))==1){
                    combinedArray = combineTwoLongBlocks(subKmerArray, seq2array(subKmer.getSeq(2)));
                //    String combinedArrayString = BinaryBlocksToString(combinedArray);
                //    System.out.println("Check combined: " + combinedArrayString);
                }else{
               //     System.out.println("warning !!!");
                    combinedArray = combineTwoLongBlocks(seq2array(subKmer.getSeq(2)), subKmerArray);
                }

                length = currentKmerSizeFromBinaryBlockArray(combinedArray);
                subKmerArray=leftShiftArray(combinedArray, length-FixingKmerSize+1);
                extension=leftShiftOutFromArray(combinedArray, length-FixingKmerSize+1);

                attribute =onlyChangeReflexivMarker(subKmer.getLong(1), 2);

                kmerList.add(RowFactory.create(subKmerArray[0], attribute, extension));

           //     String subKmerString = BinaryBlocksToString(subKmerArray);
           //     String extensionString = BinaryBlocksToString(extension);

              //  System.out.println("Check subKmer: " + subKmerString + " extension: " + extensionString + " marker: " + getReflexivMarker(attribute));
            }
            return kmerList.iterator();
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }
        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    class DSFixingKmerLeftAndRightMarkerAssignment implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList= new ArrayList<Row>();
        long attribute;
        long[] subKmerArray=new long[1];
        long[] extension;
        int FixingKmerSize=31;

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while (s.hasNext()){
                Row subKmer=s.next();


                attribute = buildingAlongFromThreeInt(1, -1, -1);

                subKmerArray[0]=subKmer.getLong(0);
                extension=leftShiftArray(subKmerArray,FixingKmerSize -1);
                subKmerArray = leftShiftOutFromArray(subKmerArray, FixingKmerSize -1);

                kmerList.add(RowFactory.create(subKmerArray[0], attribute, extension));
            }
            return kmerList.iterator();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }
        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    class DSFilterForkSubKmerWithErrorCorrection implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();

        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {
                Row subKmer = s.next();

                if (HighCoverageSubKmer.size() == 0) {
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                    );
                } else {
                    if (currentKmerSizeFromBinaryBlockArray(seq2array(subKmer.getSeq(2)))>1){ // longer kmers
                        if (subKmer.getLong(0) ==HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(0)
                                && currentKmerSizeFromBinaryBlockArray(seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2)))==1 )
                        {
                            /*
                            long[] currentArray = new long[1];
                            long[] beforeArray = new long[1];
                            currentArray[0]=subKmer.getLong(0);
                            beforeArray[0]=HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(0);
                            String current= BinaryBlocksToString(currentArray);
                            String before = BinaryBlocksToString(beforeArray);
                            System.out.println("Current: " + current + " before: " + before);
*/
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );

                        }else {
                            HighCoverageSubKmer.add(
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );
                        }
                    }else if (subKmer.getLong(0) ==HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(0)) {


                        if (currentKmerSizeFromBinaryBlockArray(seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2))) >
                               currentKmerSizeFromBinaryBlockArray(seq2array(subKmer.getSeq(2))) ){ // currentKmerSizeFromBinaryBlockArray(seq2array(subKmer.getSeq(2))) ==1

                            continue;
                        }else if (seq2array(subKmer.getSeq(2))[0] >>> 2*31 <= seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2))[0] >>> 2*31 ){
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );
                        }
                    } else {

                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                        );
                    }
                }

                // System.out.println("first leftMarker: " + leftMarker + " new leftMarker: " + getLeftMarker(attribute));
            }

            return HighCoverageSubKmer.iterator();
        }
        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

    }

    class DSFilterForkReflectedSubKmerWithErrorCorrection implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();
        Integer HighCoverLastCoverage = 0;
//        Row HighCoverKmer=null;
//                new Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>("",
        //                       new Tuple4<Integer, Long, Integer, Integer>(0, "", 0, 0));

        public Iterator<Row> call(Iterator<Row> s) {


            while (s.hasNext()) {
                Row subKmer = s.next();

                if (HighCoverageSubKmer.size() == 0) {
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                    );
                } else {
                    if (currentKmerSizeFromBinaryBlockArray(seq2array(subKmer.getSeq(2)))>1){ // longer kmers
                        if (subKmer.getLong(0) ==HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(0)
                                && currentKmerSizeFromBinaryBlockArray(seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2)))==1 )
                        {
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );

                        }else {
                            HighCoverageSubKmer.add(
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );
                        }
                    }else if (subKmer.getLong(0) ==HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(0)) {
                        if (currentKmerSizeFromBinaryBlockArray(seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2))) >
                                currentKmerSizeFromBinaryBlockArray(seq2array(subKmer.getSeq(2))) ){

                            continue;
                        }else if (seq2array(subKmer.getSeq(2))[0] >>> 2*31 <= seq2array(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(2))[0] >>> 2*31 ){
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                            );
                        }
                    } else {
                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getLong(0), subKmer.getLong(1), subKmer.getSeq(2))
                        );
                    }
                }

            }

            return HighCoverageSubKmer.iterator();
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    class DSForwardFixingSubKmerExtraction implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> TupleList = new ArrayList<Row>();
        long[] suffixBinaryArray;
        long[] prefixBinarySlot;
        Row kmerTuple;
        int FixingKmerSize=31;
        int currentSubKmerSize;
        int currentSubKmerResidue;
        int currentSubKmerBlock;

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while (s.hasNext()) {
                kmerTuple = s.next();
                /**
                 * normal Sub-kmer
                 *        Kmer      ATGCACGTTATG
                 *        Sub-Kmer  ATGCACGTTAT         marked as Integer 1 in Tuple2
                 *        Left      -----------G
                 */

                currentSubKmerSize= FixingKmerSize-1; // current sub kmer = kmerTuple -1
                currentSubKmerResidue = (currentSubKmerSize-1)%31 +1;
                currentSubKmerBlock = (currentSubKmerSize-1)/31+1;

                prefixBinarySlot=leftShiftOutFromArray((long[])kmerTuple.get(0), currentSubKmerSize);
                suffixBinaryArray = leftShiftArray((long[])kmerTuple.get(0), currentSubKmerSize);

                TupleList.add(
                        RowFactory.create(prefixBinarySlot[0], kmerTuple.getLong(1), suffixBinaryArray)
                );
            }

            return TupleList.iterator();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most


            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }


        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

    }

    class DSReflectedFixingSubKmerExtractionFromForward implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> TupleList = new ArrayList<Row>();
        long[] prefixBinaryArray;
        long[] suffixBinarySlot;
        int FixingKmerSize=31;
        Row kmerTuple;

        public Iterator<Row> call(Iterator<Row> s) throws Exception {

            while (s.hasNext()) {
                kmerTuple = s.next();

                long[] kmerTupleArray = seq2array(kmerTuple.getSeq(0));

                int length = currentKmerSizeFromBinaryBlockArray(kmerTupleArray);
                suffixBinarySlot = leftShiftArray(kmerTupleArray,length-FixingKmerSize+1);
                prefixBinaryArray = leftShiftOutFromArray(kmerTupleArray, length-FixingKmerSize+1);

                long attribute = onlyChangeReflexivMarker(kmerTuple.getLong(1), 2);

                TupleList.add(
                        RowFactory.create(suffixBinarySlot[0], attribute, prefixBinaryArray)
                );
            }

            return TupleList.iterator();
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long[] seq2array(Seq a) {
            long[] array = new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }


            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left

            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }
        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111


            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker



            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }


    }

    class DSExtendFixingKmerLoop implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;




        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            while (sIterator.hasNext()) {

                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (s.getLong(0) == tmpReflexivKmerExtendList.get(i).getLong(0)) {
                                //   System.out.println("loop array extend. first leftMarker: " + getLeftMarker(s.getLong(1)) + " rightMarker: " + getRightMarker(s.getLong(1)) + " second leftMarker: " + getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) + " rightMarker: " + getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)));
                                if (getReflexivMarker(s.getLong(1))== 1) {
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 2) {
                                        // residue length
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(tmpReflexivKmerExtendList.get(i).getSeq(2).size()-1)) / 2 + 1);
                                        // extended overall length
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) s.getSeq(2).apply(s.getSeq(2).size()-1)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                       if (getLeftMarker(s.getLong(1))< 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1)) >= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1)) >= 0 && getLeftMarker(s.getLong(1)) - tmpBlockSize >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getLeftMarker(s.getLong(1))- tmpBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentBlockSize>= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 2) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        // residue length
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(tmpReflexivKmerExtendList.get(i).getSeq(2).size()-1)) / 2 + 1);
                                        // extended overall length
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) s.getSeq(2).apply(s.getSeq(2).size()-1)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                       if (getRightMarker(s.getLong(1)) < 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1)) >= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1))>= 0 && getRightMarker(s.getLong(1))- tmpBlockSize>= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getRightMarker(s.getLong(1))- tmpBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentBlockSize >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                            //else if (dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))){

                            // }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                tmpKmerRandomizer();
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop
            tmpKmerRandomizer();
            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void singleKmerRandomizer(Row currentSubKmer) throws Exception {
            long[] currentSubKmerArray = new long[1];
            currentSubKmerArray[0]=currentSubKmer.getLong(0);
            long[] currentReflexivArray = seq2array(currentSubKmer.getSeq(2));

            if (getReflexivMarker(currentSubKmer.getLong(1)) == 1) {
                /**
                 * 00000000000000110010111010010   Long.SIZE
                 * --------------C-G-G-G-T-C-A-G   Long.SIZE - (Long.numberOfLeadingZeros / 2 + 1)
                 * --------------^-Length marker
                 */
                int currentSuffixLength =  currentKmerSizeFromBinaryBlockArray(currentReflexivArray);  // Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1); // xx01-------
                long[] newReflexivSubKmer; //= new long[param.subKmerBinarySlots];
                // long newReflexivLong;

                if (randomReflexivMarker == 2) {

                    long[] combinedKmerArray = combineTwoLongBlocks(currentSubKmerArray, currentReflexivArray);

                    newReflexivSubKmer = leftShiftArray(combinedKmerArray, currentSuffixLength);

                    long[] newReflexivLongArray = leftShiftOutFromArray(combinedKmerArray, currentSuffixLength);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer[0], attribute, newReflexivLongArray)
                    );

                } else {
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer._2._1() == 2 */
                long[] newReflexivSubKmer; // = new long[param.subKmerBinarySlots];

                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray(currentSubKmerArray);

                if (randomReflexivMarker == 2) {
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */

                    long[] combinedKmerArray = combineTwoLongBlocks(currentReflexivArray, currentSubKmerArray);

                    newReflexivSubKmer= leftShiftOutFromArray(combinedKmerArray, currentSubKmerSize);
                    long[] newReflexivLongArray= leftShiftArray(combinedKmerArray, currentSubKmerSize);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);


                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer[0], attribute, newReflexivLongArray)
                    );
                }

            }

            /* an action of randomization */

            if (randomReflexivMarker == 1) {
                randomReflexivMarker = 2;
            } else { /* randomReflexivMarker == 2 */
                randomReflexivMarker = 1;
            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            //     String arrayAString = BinaryBlocksToString(arrayA);
            //    String arrayBString = BinaryBlocksToString(arrayB);

            //     System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);

            if (aLength>=bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                if (Arrays.equals(shorterVersion, arrayB)){
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param forwardSubKmer
         * @param reflexedSubKmer
         */

        public void reflexivExtend(Row forwardSubKmer, Row reflexedSubKmer, int bubbleDistance) throws Exception {

             /* forward   ATCGATCG, 1, ------ */
             /* reflexed  ------, 2, ATCGATCG */

            int forwardSuffixLength = currentKmerSizeFromBinaryBlockArray(seq2array(forwardSubKmer.getSeq(2)));
            int reflexedPrefixLength = currentKmerSizeFromBinaryBlockArray(seq2array(reflexedSubKmer.getSeq(2)));

            int newSubKmerLength;
            long[] longerSubKmer= new long[1];
            longerSubKmer[0]=forwardSubKmer.getLong(0);
            newSubKmerLength=currentKmerSizeFromBinaryBlockArray(longerSubKmer);

            long[] reflexedPrefixArray = seq2array(reflexedSubKmer.getSeq(2));
            long[] forwardSuffixArray = seq2array(forwardSubKmer.getSeq(2));
            long attribute = 0;


            if (randomReflexivMarker == 2) {

                long[] newReflexivSubKmer = combineTwoLongBlocks(longerSubKmer, forwardSuffixArray); // xxxxx xxxxx xxx-- + xxx--- = xxxxx xxxxx xxxxx x----
                long[] newReflexivLongArray= leftShiftOutFromArray(newReflexivSubKmer, forwardSuffixLength); // xxx--  | ---xx xxxxx xxxxx x----

                newReflexivSubKmer = leftShiftArray(newReflexivSubKmer, forwardSuffixLength); // xxxxx xxxxx xxx---
                newReflexivLongArray = combineTwoLongBlocks(reflexedPrefixArray, newReflexivLongArray); // xx--- + xxx--

                if (bubbleDistance < 0) {

                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer[0],
                                    attribute, newReflexivLongArray
                            )
                    );
                } else {
                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute= buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer[0],
                                        attribute, newReflexivLongArray
                                )
                        );
                    } else { // reflexedSubKmer right >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer[0],
                                        attribute, newReflexivLongArray
                                )
                        );
                    }
                }

                //   String newReflexivSubKmerString = BinaryBlocksToString(newReflexivSubKmer);
                //   String newReflexivLongArrayString = BinaryBlocksToString(newReflexivLongArray);

                //       System.out.println("Prefix " + newReflexivLongArrayString + " combined: " + newReflexivSubKmerString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));


                randomReflexivMarker = 1; /* an action of randomization */
            } else { /* randomReflexivMarker == 1 */

                long[] newForwardSubKmer = combineTwoLongBlocks(reflexedPrefixArray, longerSubKmer); // xx--- + xxxxx xxxxx xx--- = xxxxx xxxxx xxxx-
                long[] newForwardLongArray = leftShiftArray(newForwardSubKmer, newSubKmerLength);  // xxxxx xxxxx xxxx-  -> xx--

                newForwardSubKmer = leftShiftOutFromArray(newForwardSubKmer, newSubKmerLength); // xxxxx xxxxx xxxx- -> xxxxx xxxxx xx---|xx-
                newForwardLongArray = combineTwoLongBlocks(newForwardLongArray, forwardSuffixArray); // xx-- + xxx-- -> xxxxx

                if (bubbleDistance < 0) {
                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newForwardSubKmer[0],
                                    attribute, newForwardLongArray
                            )
                    );
                } else {

                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute= buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer[0],
                                        attribute, newForwardLongArray
                                )
                        );
                    } else { // reflexedSubKmer.getInt(4) >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer[0],
                                        attribute, newForwardLongArray
                                )
                        );
                    }
                }

                //  String newForwardSubKmerString = BinaryBlocksToString(newForwardSubKmer);
                //  String newForwardLongArrayString = BinaryBlocksToString(newForwardLongArray);

                //   System.out.println("After combine: " + newForwardSubKmerString + " suffix: " + newForwardLongArrayString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 2;
            }

             /* add current sub kmer to temporal storage */
            // tmpReflexivKmerExtendList.add(reflexedSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
                // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                    //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        /**
         *
         */
        public void tmpKmerRandomizer() throws Exception {
            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                }
            }
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

            //       String arrayAString = BinaryBlocksToString(arrayA);
            //       String arrayBString = BinaryBlocksToString(arrayB);
            if (aLength==bLength){
                //       System.out.println("equal comparator: " + arrayAString + " B: " + arrayBString);

            }

            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSExtendReflexivKmerToArrayLoop implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        // private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;




        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        //long maxBlockBinary = ~((~0L) << 2*31); // a block has 31 nucleotide


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {

            if (param.scramble ==3){
                randomReflexivMarker =1;
            }

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0)) || dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {
                             //   System.out.println("loop array extend. first leftMarker: " + getLeftMarker(s.getLong(1)) + " rightMarker: " + getRightMarker(s.getLong(1)) + " second leftMarker: " + getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) + " rightMarker: " + getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)));
                                if (getReflexivMarker(s.getLong(1))== 1) {
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 2) {
                                        // residue length
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(tmpReflexivKmerExtendList.get(i).getSeq(2).size()-1)) / 2 + 1);
                                        // extended overall length
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) s.getSeq(2).apply(s.getSeq(2).size()-1)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;


                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthTemp< lengthS){
                                            extraLength=lengthS-lengthTemp;
                                        }

                                        if (lengthS<lengthTemp){ // longer kmer overlapped shorter kmer
                                            singleKmerRandomizer(s);
                                            break;
                                        }else if (getLeftMarker(s.getLong(1))< 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1)) >= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1)) >= 0 && getLeftMarker(s.getLong(1)) - tmpBlockSize >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getLeftMarker(s.getLong(1))- tmpBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentBlockSize -extraLength >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 2) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        // residue length
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) tmpReflexivKmerExtendList.get(i).getSeq(2).apply(tmpReflexivKmerExtendList.get(i).getSeq(2).size()-1)) / 2 + 1);
                                        // extended overall length
                                        int tmpBlockSize = (tmpReflexivKmerExtendList.get(i).getSeq(2).length() - 1) * 31 + tmpReflexivKmerSuffixLength;
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros((Long) s.getSeq(2).apply(s.getSeq(2).size()-1)) / 2 + 1);
                                        int currentBlockSize = (s.getSeq(2).length() - 1) * 31 + currentReflexivKmerSuffixLength;

                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthS< lengthTemp){
                                            extraLength=lengthTemp-lengthS;
                                        }

                                        if (lengthTemp<lengthS){ // longer kmer overlapped shorter kmer
                                            singleKmerRandomizer(s);
                                            break;
                                        }else if (getRightMarker(s.getLong(1)) < 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1)) >= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1))>= 0 && getRightMarker(s.getLong(1))- tmpBlockSize -extraLength>= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getRightMarker(s.getLong(1))- tmpBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentBlockSize >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentBlockSize);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                            //else if (dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))){

                           // }

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                tmpKmerRandomizer();
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop
            tmpKmerRandomizer();
            return reflexivKmerConcatList.iterator();
        }

        /**
         *
         * @param currentSubKmer
         */
        public void singleKmerRandomizer(Row currentSubKmer) throws Exception {
            long[] currentSubKmerArray = seq2array(currentSubKmer.getSeq(0));
            long[] currentReflexivArray = seq2array(currentSubKmer.getSeq(2));

            if (getReflexivMarker(currentSubKmer.getLong(1)) == 1) {
                /**
                 * 00000000000000110010111010010   Long.SIZE
                 * --------------C-G-G-G-T-C-A-G   Long.SIZE - (Long.numberOfLeadingZeros / 2 + 1)
                 * --------------^-Length marker
                 */
                int currentSuffixLength =  currentKmerSizeFromBinaryBlockArray(currentReflexivArray);  // Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1); // xx01-------
                long[] newReflexivSubKmer; //= new long[param.subKmerBinarySlots];
                // long newReflexivLong;

                if (randomReflexivMarker == 2) {

                    long[] combinedKmerArray = combineTwoLongBlocks(currentSubKmerArray, currentReflexivArray);

                    newReflexivSubKmer = leftShiftArray(combinedKmerArray, currentSuffixLength);

                    long[] newReflexivLongArray = leftShiftOutFromArray(combinedKmerArray, currentSuffixLength);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray)
                    );

                } else {
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer._2._1() == 2 */
                long[] newReflexivSubKmer; // = new long[param.subKmerBinarySlots];

                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray(currentSubKmerArray);

                if (randomReflexivMarker == 2) {
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */

                    long[] combinedKmerArray = combineTwoLongBlocks(currentReflexivArray, currentSubKmerArray);

                    newReflexivSubKmer= leftShiftOutFromArray(combinedKmerArray, currentSubKmerSize);
                    long[] newReflexivLongArray= leftShiftArray(combinedKmerArray, currentSubKmerSize);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);


                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray)
                    );
                }

            }

            /* an action of randomization */

            if (randomReflexivMarker == 1) {
                randomReflexivMarker = 2;
            } else { /* randomReflexivMarker == 2 */
                randomReflexivMarker = 1;
            }
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

       //     String arrayAString = BinaryBlocksToString(arrayA);
        //    String arrayBString = BinaryBlocksToString(arrayB);

       //     System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);

            if (aLength>=bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                if (Arrays.equals(shorterVersion, arrayB)){
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param forwardSubKmer
         * @param reflexedSubKmer
         */

        public void reflexivExtend(Row forwardSubKmer, Row reflexedSubKmer, int bubbleDistance) throws Exception {

             /* forward   ATCGATCG, 1, ------ */
             /* reflexed  ------, 2, ATCGATCG */

            int forwardSuffixLength = currentKmerSizeFromBinaryBlockArray(seq2array(forwardSubKmer.getSeq(2)));
            int forwardSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(forwardSubKmer.getSeq(0)));

            int reflexedPrefixLength = currentKmerSizeFromBinaryBlockArray(seq2array(reflexedSubKmer.getSeq(2)));
            int reflexedSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(reflexedSubKmer.getSeq(0)));


            int newSubKmerLength;
            long[] longerSubKmer;

            int extraLength=0;
            if (forwardSubKmerLength>reflexedSubKmerLength){
                extraLength=forwardSubKmerLength-reflexedSubKmerLength;
            }

            if (forwardSubKmerLength >= reflexedSubKmerLength){ // In reality, it is always forwardSubKmer longer than or equal to reflexedSubKmer
                newSubKmerLength=forwardSubKmerLength;
                longerSubKmer=seq2array(forwardSubKmer.getSeq(0));
            }else{
                newSubKmerLength=reflexedSubKmerLength;
                longerSubKmer=seq2array(reflexedSubKmer.getSeq(0));
            }

            long[] reflexedPrefixArray = seq2array(reflexedSubKmer.getSeq(2));
            long[] forwardSuffixArray = seq2array(forwardSubKmer.getSeq(2));
            long attribute = 0;


            if (randomReflexivMarker == 2) {

                long[] newReflexivSubKmer = combineTwoLongBlocks(longerSubKmer, forwardSuffixArray); // xxxxx xxxxx xxx-- + xxx--- = xxxxx xxxxx xxxxx x----
                long[] newReflexivLongArray= leftShiftOutFromArray(newReflexivSubKmer, forwardSuffixLength); // xxx--  | ---xx xxxxx xxxxx x----

                newReflexivSubKmer = leftShiftArray(newReflexivSubKmer, forwardSuffixLength); // xxxxx xxxxx xxx---
                newReflexivLongArray = combineTwoLongBlocks(reflexedPrefixArray, newReflexivLongArray); // xx--- + xxx--

                if (bubbleDistance < 0) {

                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer,
                                    attribute, newReflexivLongArray
                            )
                    );
                } else {
                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute= buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer,
                                        attribute, newReflexivLongArray
                                )
                        );
                    } else { // reflexedSubKmer right >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer,
                                        attribute, newReflexivLongArray
                                )
                        );
                    }
                }

             //   String newReflexivSubKmerString = BinaryBlocksToString(newReflexivSubKmer);
             //   String newReflexivLongArrayString = BinaryBlocksToString(newReflexivLongArray);

         //       System.out.println("Prefix " + newReflexivLongArrayString + " combined: " + newReflexivSubKmerString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));


                randomReflexivMarker = 1; /* an action of randomization */
            } else { /* randomReflexivMarker == 1 */

                long[] newForwardSubKmer = combineTwoLongBlocks(reflexedPrefixArray, longerSubKmer); // xx--- + xxxxx xxxxx xx--- = xxxxx xxxxx xxxx-
                long[] newForwardLongArray = leftShiftArray(newForwardSubKmer, newSubKmerLength);  // xxxxx xxxxx xxxx-  -> xx--

                newForwardSubKmer = leftShiftOutFromArray(newForwardSubKmer, newSubKmerLength); // xxxxx xxxxx xxxx- -> xxxxx xxxxx xx---|xx-
                newForwardLongArray = combineTwoLongBlocks(newForwardLongArray, forwardSuffixArray); // xx-- + xxx-- -> xxxxx

                if (bubbleDistance < 0) {
                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newForwardSubKmer,
                                    attribute, newForwardLongArray
                            )
                    );
                } else {

                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute= buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray
                                )
                        );
                    } else { // reflexedSubKmer.getInt(4) >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray
                                )
                        );
                    }
                }

              //  String newForwardSubKmerString = BinaryBlocksToString(newForwardSubKmer);
              //  String newForwardLongArrayString = BinaryBlocksToString(newForwardLongArray);

             //   System.out.println("After combine: " + newForwardSubKmerString + " suffix: " + newForwardLongArrayString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 2;
            }

             /* add current sub kmer to temporal storage */
            // tmpReflexivKmerExtendList.add(reflexedSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(S
                    //   RowFactory.create(S.getLong(0),
                    //                   S.getInt(1), S.get(2), S.getInt(3), S.getInt(4)
                    //   )
            );
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
                // String rightBlocksString = BinaryBlocksToString(rightBlocks);
               // String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
                  //  String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

                // String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        /**
         *
         */
        public void tmpKmerRandomizer() throws Exception {
            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                }
            }
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

     //       String arrayAString = BinaryBlocksToString(arrayA);
     //       String arrayBString = BinaryBlocksToString(arrayB);
            if (aLength==bLength){
         //       System.out.println("equal comparator: " + arrayAString + " B: " + arrayBString);

            }

            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    /**
     *
     */


    class DSExtendReflexivKmerToArrayFirstTime implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        //       private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2.getLong(0) represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Row>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))|| dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {
                             //   System.out.println("first array extend. first leftMarker: " + getLeftMarker(s.getLong(1)) + " rightMarker: " + getRightMarker(s.getLong(1)) + " second leftMarker: " + getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) + " rightMarker: " + getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)));
                                if (getReflexivMarker(s.getLong(1)) == 1) {
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 2) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(tmpReflexivKmerExtendList.get(i).getLong(2)) / 2 + 1);
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(s.getLong(2)) / 2 + 1);

                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthTemp< lengthS){
                                            extraLength=lengthS-lengthTemp;
                                        }

                                        if (lengthS<lengthTemp){
                                            singleKmerRandomizer(s);
                                            break;
                                        } else if (getLeftMarker(s.getLong(1))< 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1))>= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1))>= 0 && getLeftMarker(s.getLong(1))- tmpReflexivKmerSuffixLength >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getLeftMarker(s.getLong(1))- tmpReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentReflexivKmerSuffixLength -extraLength>= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 2) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))== 1) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(tmpReflexivKmerExtendList.get(i).getLong(2)) / 2 + 1);
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(s.getLong(2)) / 2 + 1);

                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthS< lengthTemp){
                                            extraLength=lengthTemp-lengthS;
                                        }

                                        if (lengthTemp<lengthS){ // longer kmer overlapped shorter kmer
                                            singleKmerRandomizer(s);
                                            break;
                                        }else if (getRightMarker(s.getLong(1)) < 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))< 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1)) >= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1)) >= 0 && getRightMarker(s.getLong(1)) - tmpReflexivKmerSuffixLength -extraLength>= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getRightMarker(s.getLong(1)) - tmpReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentReflexivKmerSuffixLength >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }

                            //else if (dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0)) ){

                            //}

                        /* new Sub-kmer group section */
                            else { /* s.getLong(0) != tmpReflexivKmerExtendList.get(i).getLong(0)()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                tmpKmerRandomizer();
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop
            tmpKmerRandomizer();


            return reflexivKmerConcatList.iterator();
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

         //   String arrayAString = BinaryBlocksToString(arrayA);
         //   String arrayBString = BinaryBlocksToString(arrayB);

         //   System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);

            if (aLength>=bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                if (Arrays.equals(shorterVersion, arrayB)){
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }



        private boolean subKmerSlotComparator(Seq a, Seq b) {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

         //   String arrayAString = BinaryBlocksToString(arrayA);
         //   String arrayBString = BinaryBlocksToString(arrayB);
            if (aLength==bLength){
       //         System.out.println("equal comparator: " + arrayAString + " B: " + arrayBString);

            }

            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }


        /**
         *
         * @param currentSubKmer
         */
        public void singleKmerRandomizer(Row currentSubKmer) throws Exception {
            long[] currentSubKmerArray = seq2array(currentSubKmer.getSeq(0));

            if (getReflexivMarker(currentSubKmer.getLong(1)) == 1) {
                /**
                 * 00000000000000110010111010010   Long.SIZE
                 * --------------C-G-G-G-T-C-A-G   Long.SIZE - (Long.numberOfLeadingZeros / 2 + 1)
                 * --------------^-Length marker
                 */
         //   String subkmerString = BinaryBlocksToString(currentSubKmerArray);
               // System.out.println("subKmerString: " + subkmerString);


                int currentSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1); // xx01-------
                long[] newReflexivSubKmer; //= new long[param.subKmerBinarySlots];
               // long newReflexivLong;

                if (randomReflexivMarker == 2) {

                    long[] currentSuffixArray = new long[1];
                    currentSuffixArray[0]=currentSubKmer.getLong(2);
                    long[] combinedKmerArray = combineTwoLongBlocks(currentSubKmerArray, currentSuffixArray);

                    newReflexivSubKmer = leftShiftArray(combinedKmerArray, currentSuffixLength);

                    long[] newReflexivLongArray = leftShiftOutFromArray(combinedKmerArray, currentSuffixLength);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray)
                    );

                } else {
                    long[] newReflexivLongArray = new long[1];
                    newReflexivLongArray[0]= currentSubKmer.getLong(2);
                    reflexivKmerConcatList.add(
                            RowFactory.create(currentSubKmer.getSeq(0), currentSubKmer.getLong(1), newReflexivLongArray)
                    );
                }
            } else { /* currentSubKmer._2._1() == 2 */
                int currentPrefixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1);
                long[] newReflexivSubKmer; // = new long[param.subKmerBinarySlots];
                Long newReflexivLong;
                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray(currentSubKmerArray);

                if (randomReflexivMarker == 2) {
                    long[] newReflexivLongArray = new long[1];
                    newReflexivLongArray[0]= currentSubKmer.getLong(2);
                    reflexivKmerConcatList.add(
                            RowFactory.create(currentSubKmer.getSeq(0), currentSubKmer.getLong(1), newReflexivLongArray)
                    );
                } else { /* randomReflexivMarker == 1 */

                    long[] currentPrefixArray = new long[1];
                    currentPrefixArray[0]= currentSubKmer.getLong(2);
                    long[] combinedKmerArray = combineTwoLongBlocks(currentPrefixArray, currentSubKmerArray);

                    newReflexivSubKmer= leftShiftOutFromArray(combinedKmerArray, currentSubKmerSize);
                    long[] newReflexivLongArray= leftShiftArray(combinedKmerArray, currentSubKmerSize);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);


                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray)
                    );
                }

            }

            /* an action of randomization */

            if (randomReflexivMarker == 1) {
                randomReflexivMarker = 2;
            } else { /* randomReflexivMarker == 2 */
                randomReflexivMarker = 1;
            }
        }

        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param forwardSubKmer
         * @param reflexedSubKmer
         */

        public void reflexivExtend(Row forwardSubKmer, Row reflexedSubKmer, int bubbleDistance) throws Exception {

             /* forward   ATCGATCG, 1, ------ */
             /* reflexed  ------, 2, ATCGATCG */

            int forwardSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(forwardSubKmer.getLong(2)) / 2 + 1);
            int forwardSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(forwardSubKmer.getSeq(0)));

            int reflexedPrefixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(reflexedSubKmer.getLong(2)) / 2 + 1);
            int reflexedSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(reflexedSubKmer.getSeq(0)));

            long attribute=0;

            int newSubKmerLength;
            long[] longerSubKmer;

            int extraLength=0;
            if (forwardSubKmerLength>reflexedSubKmerLength){
                extraLength=forwardSubKmerLength-reflexedSubKmerLength;
            }

            if (forwardSubKmerLength >= reflexedSubKmerLength){ // In reality, it is always forwardSubKmer longer than or equal to reflexedSubKmer
                newSubKmerLength=forwardSubKmerLength;
                longerSubKmer= seq2array(forwardSubKmer.getSeq(0));
            }else{
                newSubKmerLength=reflexedSubKmerLength;
                longerSubKmer=seq2array(reflexedSubKmer.getSeq(0));
            }

            long[] reflexedPrefixArray = new long[1];
            reflexedPrefixArray[0] = reflexedSubKmer.getLong(2);

            long[] forwardSuffixArray = new long[1];
            forwardSuffixArray[0] = forwardSubKmer.getLong(2);


            if (randomReflexivMarker == 2) {

                long[] newReflexivSubKmer = combineTwoLongBlocks(longerSubKmer, forwardSuffixArray); // xxxxx xxxxx xxx-- + xxx--- = xxxxx xxxxx xxxxx x----
                long[] newReflexivLongArray= leftShiftOutFromArray(newReflexivSubKmer, forwardSuffixLength); // xxx--  | ---xx xxxxx xxxxx x----

                newReflexivSubKmer = leftShiftArray(newReflexivSubKmer, forwardSuffixLength); // xxxxx xxxxx xxx---
                newReflexivLongArray = combineTwoLongBlocks(reflexedPrefixArray, newReflexivLongArray); // xx--- + xxx--

                if (bubbleDistance < 0) {
                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer,
                                    attribute, newReflexivLongArray
                            )
                    );
                } else {
                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer,
                                        attribute, newReflexivLongArray
                                )
                        );
                    } else { // reflexedSubKmer right >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer,
                                        attribute, newReflexivLongArray
                                )
                        );
                    }
                }

             //   String newReflexivSubKmerString = BinaryBlocksToString(newReflexivSubKmer);
             //   String newReflexivLongArrayString = BinaryBlocksToString(newReflexivLongArray);

       //         System.out.println("Prefix " + newReflexivLongArrayString + " combined: " + newReflexivSubKmerString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 1; /* an action of randomization */
            } else { /* randomReflexivMarker == 1 */

                long[] newForwardSubKmer = combineTwoLongBlocks(reflexedPrefixArray, longerSubKmer); // xx--- + xxxxx xxxxx xx--- = xxxxx xxxxx xxxx-
                long[] newForwardLongArray = leftShiftArray(newForwardSubKmer, newSubKmerLength);  // xxxxx xxxxx xxxx-  -> xx--

                newForwardSubKmer = leftShiftOutFromArray(newForwardSubKmer, newSubKmerLength); // xxxxx xxxxx xxxx- -> xxxxx xxxxx xx---|xx-
                newForwardLongArray = combineTwoLongBlocks(newForwardLongArray, forwardSuffixArray); // xx-- + xxx-- -> xxxxx

                if (bubbleDistance < 0) {

                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newForwardSubKmer,
                                    attribute, newForwardLongArray
                            )
                    );
                } else {

                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray
                                )
                        );
                    } else { // reflexedSubKmer.getInt(4) >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray
                                )
                        );
                    }
                }

            //    String newForwardSubKmerString = BinaryBlocksToString(newForwardSubKmer);
            //    String newForwardLongArrayString = BinaryBlocksToString(newForwardLongArray);

         //       System.out.println("After combine: " + newForwardSubKmerString + " suffix: " + newForwardLongArrayString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 2;
            }

             /* add current sub kmer to temporal storage */
            // tmpReflexivKmerExtendList.add(reflexedSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();

            tmpReflexivKmerExtendList.add(
                    RowFactory.create(S.getSeq(0),
                            S.getLong(1), S.getLong(2)
                    )
            );
        }

        /**
         *
         */
        public void tmpKmerRandomizer() throws Exception {
            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                }
            }
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
             //   String rightBlocksString = BinaryBlocksToString(rightBlocks);
             //   String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
              //      String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

             //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

    }

    /**MarkerKmerBinaryEncoder
     *
     */


    class DSExtendReflexivKmer implements MapPartitionsFunction<Row, Row>, Serializable {

        /* marker to identify similar SubKmers in the loop sequence */
        private int lineMarker = 1;

        /* 1 stands for forward sub-kmer */
        /* 2 stands for reflexiv sub-kmer */
        //     private int randomReflexivMarker = ThreadLocalRandom.current().nextInt(1, 3);
        private int randomReflexivMarker = 2;

        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);


        /* temporary capsule to store identical SubKmer units */
        List<Row> tmpReflexivKmerExtendList = new ArrayList<Row>();

        /* return capsule of extend Tuples for next iteration*/
        List<Row> reflexivKmerConcatList = new ArrayList<Row>();

        /**
         *
         * @param sIterator is the input data structure Tuple2<SubKmer, Tuple2<Marker, TheRestSequence>>
         *          s._1 represents sub kmer sequence
         *          s._2._1 represents sub kmer marker: 1, for forward sub kmer;
         *                                              2, for reverse (reflexiv) sub kmer;
         *          s._2._2 represents the rest sequence.
         *          s._2._2 represents the coverage of the K-mer
         * @return a list of extended Tuples for next iteration
         */
        public Iterator<Row> call(Iterator<Row> sIterator) throws Exception {

            while (sIterator.hasNext()) {
                Row s = sIterator.next();

            /* receive the first sub-kmer, set new units */
                if (lineMarker == 1) {
                    resetSubKmerGroup(s);

                    // return reflexivKmerConcatList.iterator();
                }

            /* removal condition */
                /**
                 * Deprecated function for killer k-mers
                 */

            /* next element of RDD */
                else {/* if (lineMarker >= 2){ */
                /* initiate a new capsule for the current sub-kmer group */
                    //      reflexivKmerConcatList = new ArrayList<Row>();

                    if (tmpReflexivKmerExtendList.size() == 0) {
                        directKmerComparison(s);
                    } else { /* tmpReflexivKmerExtendList.size() != 0 */
                        for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) { // the tmpReflexivKmerExtendList is changing dynamically
                            if (subKmerSlotComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0)) || dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))) {

                                long[] overhang1= new long[1];
                                overhang1[0]=s.getLong(2);
                                long[] overhang2= new long[1];
                                overhang2[0]=tmpReflexivKmerExtendList.get(i).getLong(2);
                            //    System.out.println("to see if it happens. first leftMarker: " + getLeftMarker(s.getLong(1)) + " rightMarker: " + getRightMarker(s.getLong(1)) + " reflexivMarker: " + getReflexivMarker(s.getLong(1)) + " overhang: " + BinaryBlocksToString(overhang1) + " second leftMarker: " + getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) + " rightMarker: " + getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) + " reflexivMarker: " + getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1))+ " overhang2: "+ BinaryBlocksToString(overhang2));
                                if (getReflexivMarker(s.getLong(1)) == 1) {
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 2) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(tmpReflexivKmerExtendList.get(i).getLong(2)) / 2 + 1);
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(s.getLong(2)) / 2 + 1);

                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthTemp<lengthS){
                                            extraLength=lengthS-lengthTemp;
                                        }

                                        if (lengthS<lengthTemp){  // longer one overlapped the shorter one, not extending until short kmer upgrades.
                                            singleKmerRandomizer(s);
                                            break;
                                        }else if (getLeftMarker(s.getLong(1)) < 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) < 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1))>= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(s.getLong(1))>= 0 && getLeftMarker(s.getLong(1))- tmpReflexivKmerSuffixLength >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getLeftMarker(s.getLong(1))- tmpReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) >= 0 && getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentReflexivKmerSuffixLength -extraLength >= 0) {
                                            reflexivExtend(s, tmpReflexivKmerExtendList.get(i), getRightMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentReflexivKmerSuffixLength); // extraLength will be deducted inside the function
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 1) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    }
                                } else { /* if (s.getInt(1) == 2) { */
                                    if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 2) {
                                        singleKmerRandomizer(s);
                                        //directKmerComparison(s);
                                        break;
                                    } else if (getReflexivMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) == 1) {
                                        int tmpReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(tmpReflexivKmerExtendList.get(i).getLong(2)) / 2 + 1);
                                        int currentReflexivKmerSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(s.getLong(2)) / 2 + 1);

                                        int lengthS = currentKmerSizeFromBinaryBlockArray(seq2array(s.getSeq(0)));
                                        int lengthTemp= currentKmerSizeFromBinaryBlockArray(seq2array(tmpReflexivKmerExtendList.get(i).getSeq(0)));

                                        int extraLength=0;
                                        if (lengthS< lengthTemp){
                                            extraLength=lengthTemp-lengthS;
                                        }

                                        if (lengthTemp<lengthS){ // longer kmer overlapped shorter kmer
                                            singleKmerRandomizer(s);
                                            break;
                                        }else if (getRightMarker(s.getLong(1))< 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) < 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1))>= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, -1);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getRightMarker(s.getLong(1))>= 0 && getRightMarker(s.getLong(1))- tmpReflexivKmerSuffixLength - extraLength >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getRightMarker(s.getLong(1))- tmpReflexivKmerSuffixLength); // extraLength will be deducted inside the function
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else if (getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))>= 0 && getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1))- currentReflexivKmerSuffixLength >= 0) {
                                            reflexivExtend(tmpReflexivKmerExtendList.get(i), s, getLeftMarker(tmpReflexivKmerExtendList.get(i).getLong(1)) - currentReflexivKmerSuffixLength);
                                            tmpReflexivKmerExtendList.remove(i); /* already extended */
                                            break;
                                        } else {
                                            singleKmerRandomizer(s);
                                            break;
                                        }
                                    }
                                }
                            /* return reflexivKmerConcatList.iterator(); */
                            }
                            /**
                             *  comparing k-mers with different length but identical prefix  xxxxxxc--     c is the marker
                             *                                                               xxxxxxatg gttcatgc--
                             *
                             *  same process as k-mers with equal length
                             */

                           // else if (dynamicSubKmerComparator(s.getSeq(0), tmpReflexivKmerExtendList.get(i).getSeq(0))){
                           // }


                        /* new Sub-kmer group section */
                            else { /* s._1 != tmpReflexivKmerExtendList.get(i)._1()*/
                                //  if (lineMarker == 2) { // lineMarker == 2 represents the second line of the partition
                                //     singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                                // }
                                //  singleKmerRandomizer(s);
                                tmpKmerRandomizer();
                                resetSubKmerGroup(s);
                                break;
                            }
                        } /* end of the while loop */
                    }// end of else condition

                    lineMarker++;
                    // return reflexivKmerConcatList.iterator();
                }
            } // while loop
            tmpKmerRandomizer();

            return reflexivKmerConcatList.iterator();
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

          //  String arrayAString = BinaryBlocksToString(arrayA);
          //  String arrayBString = BinaryBlocksToString(arrayB);

         //   System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);


            if (aLength>bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
             //   String longer = BinaryBlocksToString(shorterVersion);
            //    String shorter = BinaryBlocksToString(arrayB);
                // System.out.println("longer: " + longer + " shorter: " + shorter);
                // if (shorterVersion.length>=2 && arrayB.length >=2) {
                //    System.out.println("longer array: " + shorterVersion[0] + " "  + shorterVersion[1] + " shorter array: " + arrayB[0] + " " + arrayB[1]);
                //}
                if (Arrays.equals(shorterVersion, arrayB)){
                    //  if (shorterVersion.length>=2){
                    //        System.out.println("marker!!!");
                    // }
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }


        private boolean subKmerSlotComparator(Seq a, Seq b) {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

        //    String arrayAString = BinaryBlocksToString(arrayA);
        //    String arrayBString = BinaryBlocksToString(arrayB);
            if (aLength==bLength){
        //        System.out.println("equal comparator: " + arrayAString + " B: " + arrayBString);

            }

            if (a.length() != b.length()){
                return false;
            }

            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }


        public void singleKmerRandomizer(Row currentSubKmer) throws Exception {
            long[] currentSubKmerArray = seq2array(currentSubKmer.getSeq(0));

            if (getReflexivMarker(currentSubKmer.getLong(1)) == 1) {
                /**
                 * 00000000000000110010111010010   Long.SIZE
                 * --------------C-G-G-G-T-C-A-G   Long.SIZE - (Long.numberOfLeadingZeros / 2 + 1)
                 * --------------^-Length marker
                 */
                int currentSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1); // xx01-------
                long[] newReflexivSubKmer; //= new long[param.subKmerBinarySlots];
                long newReflexivLong;

                if (randomReflexivMarker == 2) {

                    newReflexivSubKmer = leftShiftArray(currentSubKmerArray, currentSuffixLength);
                    long[] newReflexivLongArray = leftShiftOutFromArray(currentSubKmerArray, currentSuffixLength);
                    newReflexivLong = newReflexivLongArray[0];

                    long[] suffixArray = new long[1];
                    suffixArray[0]= currentSubKmer.getLong(2);
                    newReflexivSubKmer = combineTwoLongBlocks(newReflexivSubKmer, suffixArray);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

 //                   System.out.println("checking singleKmerRandomizer leftMarker 2: " + getLeftMarker(attribute));

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLong)
                    );

                } else {
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer._2._1() == 2 */
                int currentPrefixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1);
                long[] newReflexivSubKmer; // = new long[param.subKmerBinarySlots];
                Long newReflexivLong;
                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray(currentSubKmerArray);

                if (randomReflexivMarker == 2) {
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */

                    int rightShiftRemain = currentSubKmerSize-currentPrefixLength;
                    long[] rightShiftRemainBlocks = leftShiftOutFromArray(currentSubKmerArray, rightShiftRemain);
                    long[] prefixArray = new long[1];
                    prefixArray[0]=currentSubKmer.getLong(2);
                    newReflexivSubKmer = combineTwoLongBlocks(prefixArray, rightShiftRemainBlocks);

                    newReflexivLong = (leftShiftArray(currentSubKmerArray, rightShiftRemain))[0];

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

  //                  System.out.println("checking singleKmerRandomizer leftMarker 1: " + getLeftMarker(attribute));

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLong)
                    );
                }

            }

            /* an action of randomization */

            if (randomReflexivMarker == 1) {
                randomReflexivMarker = 2;
            } else { /* randomReflexivMarker == 2 */
                randomReflexivMarker = 1;
            }
        }
        /**
         *
         * @param currentSubKmer
         */


        /**
         *
         * @param currentSubKmer
         */
        public void directKmerComparison(Row currentSubKmer) {
            tmpReflexivKmerExtendList.add(currentSubKmer);
        }

        /**
         *
         * @param forwardSubKmer
         * @param reflexedSubKmer
         */
        public void reflexivExtend(Row forwardSubKmer, Row reflexedSubKmer, int bubbleDistance) throws Exception {

             /* forward   ATCGATCG, 1, ------ */
             /* reflexed  ------, 2, ATCGATCG */
            long attribute=0;

            int forwardSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(forwardSubKmer.getLong(2)) / 2 + 1);
            int forwardSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(forwardSubKmer.getSeq(0)));

            int reflexedPrefixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(reflexedSubKmer.getLong(2)) / 2 + 1);
            int reflexedSubKmerLength = currentKmerSizeFromBinaryBlockArray(seq2array(reflexedSubKmer.getSeq(0)));

            int newSubKmerLength;
            long[] longerSubKmer;

            int extraLength=0;
            if (forwardSubKmerLength>reflexedSubKmerLength){
                extraLength=forwardSubKmerLength-reflexedSubKmerLength;
            }

            if (forwardSubKmerLength >= reflexedSubKmerLength){ // In reality, it is always forwardSubKmer longer than or equal to reflexedSubKmer
                newSubKmerLength=forwardSubKmerLength;
                longerSubKmer= seq2array(forwardSubKmer.getSeq(0));
            }else{
                newSubKmerLength=reflexedSubKmerLength;
                longerSubKmer=seq2array(reflexedSubKmer.getSeq(0));
            }

            long[] reflexedPrefixArray = new long[1];
            reflexedPrefixArray[0] = reflexedSubKmer.getLong(2);

            long[] forwardSuffixArray = new long[1];
            forwardSuffixArray[0] = forwardSubKmer.getLong(2);

            if (randomReflexivMarker == 2) {

                long[] newReflexivSubKmer = combineTwoLongBlocks(longerSubKmer, forwardSuffixArray); // xxxxx xxxxx xxx-- + xxx--- = xxxxx xxxxx xxxxx x----
                long[] newReflexivLongArray= leftShiftOutFromArray(newReflexivSubKmer, forwardSuffixLength); // xxx--  | ---xx xxxxx xxxxx x----

                newReflexivSubKmer = leftShiftArray(newReflexivSubKmer, forwardSuffixLength); // xxxxx xxxxx xxx---
           //     String newForwardSubKmerStringTemp = BinaryBlocksToString(newReflexivSubKmer);
           //     System.out.println("after leftshiftout: " + newForwardSubKmerStringTemp);
                newReflexivLongArray = combineTwoLongBlocks(reflexedPrefixArray, newReflexivLongArray); // xx--- + xxx--

                if (bubbleDistance < 0) {
         //           System.out.println("before: " + randomReflexivMarker + " left: " + getLeftMarker(reflexedSubKmer.getLong(1)) + " right: " + getRightMarker(forwardSubKmer.getLong(1)));
                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray[0])
                    );
                } else {
                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1)) >=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray[0])
                        );
                    } else {
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newReflexivSubKmer, attribute, newReflexivLongArray[0])
                        );
                    }
                }

             //   String newReflexivSubKmerString = BinaryBlocksToString(newReflexivSubKmer);
            //    String newReflexivLongArrayString = BinaryBlocksToString(newReflexivLongArray);

         //       System.out.println("Prefix " + newReflexivLongArrayString + " combined: " + newReflexivSubKmerString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 1; /* an action of randomization */
            } else { /* randomReflexivMarker == 1 */

                long[] newForwardSubKmer = combineTwoLongBlocks(reflexedPrefixArray, longerSubKmer); // xx--- + xxxxx xxxxx xx--- = xxxxx xxxxx xxxx-
                long[] newForwardLongArray = leftShiftArray(newForwardSubKmer, newSubKmerLength);  // xxxxx xxxxx xxxx-  -> xx--

                newForwardSubKmer = leftShiftOutFromArray(newForwardSubKmer, newSubKmerLength); // xxxxx xxxxx xxxx- -> xxxxx xxxxx xx---|xx-
                newForwardLongArray = combineTwoLongBlocks(newForwardLongArray, forwardSuffixArray); // xx-- + xxx-- -> xxxxx


                if (bubbleDistance < 0) {
            //        System.out.println("before: " + randomReflexivMarker + " left: " + getLeftMarker(reflexedSubKmer.getLong(1)) + " right: " + getRightMarker(forwardSubKmer.getLong(1)));
                    int left=0;
                    int right=0;
                    if (getLeftMarker(reflexedSubKmer.getLong(1))>=0){
                        left = getLeftMarker(reflexedSubKmer.getLong(1));
                    }else{
                        left= getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength;
                    }

                    if (getRightMarker(forwardSubKmer.getLong(1))>=0){
                        right = getRightMarker(forwardSubKmer.getLong(1));
                    }else {
                        right = getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength;
                    }

                    attribute = buildingAlongFromThreeInt(randomReflexivMarker, left, right);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newForwardSubKmer, attribute, newForwardLongArray[0])
                    );
                } else {
                    if (getLeftMarker(forwardSubKmer.getLong(1)) > 0) {
                        if (getRightMarker(forwardSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(forwardSubKmer.getLong(1)));
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, bubbleDistance, getRightMarker(reflexedSubKmer.getLong(1))-forwardSuffixLength-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray[0]
                                )
                        );
                    } else { // reflexedSubKmer.getInt(4) >0
                        if (getLeftMarker(reflexedSubKmer.getLong(1))>=0) {
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(reflexedSubKmer.getLong(1)), bubbleDistance-extraLength);
                        }else{
                            attribute = buildingAlongFromThreeInt(randomReflexivMarker, getLeftMarker(forwardSubKmer.getLong(1))-reflexedPrefixLength, bubbleDistance-extraLength);
                        }
                        reflexivKmerConcatList.add(
                                RowFactory.create(newForwardSubKmer,
                                        attribute, newForwardLongArray[0]
                                )
                        );
                    }
                }

            //    String newForwardSubKmerString = BinaryBlocksToString(newForwardSubKmer);
             //   String newForwardLongArrayString = BinaryBlocksToString(newForwardLongArray);

            //    System.out.println("After combine: " + newForwardSubKmerString + " suffix: " + newForwardLongArrayString + " reflexivMarker: " + getReflexivMarker(attribute) + " leftMarker: " + getLeftMarker(attribute) + " rightMarker: " + getRightMarker(attribute));

                randomReflexivMarker = 2;
            }

             /* add current sub kmer to temporal storage */
            // tmpReflexivKmerExtendList.add(reflexedSubKmer);
        }

        /**
         *
         * @param S
         */
        public void resetSubKmerGroup(Row S) {
            if (lineMarker == 1) {
                lineMarker = 2;
            } else {
                lineMarker = 3; /* reset to new sub-kmer group */
            }
            /* re-reflex all single kmers in the sub-kmer group */
//            if (tmpReflexivKmerExtendList.size() != 0) {
//                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
            //                   singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
            //               }
            //          }

            tmpReflexivKmerExtendList = new ArrayList<Row>();
            tmpReflexivKmerExtendList.add(
                    RowFactory.create(S.getSeq(0),
                            S.getLong(1), S.getLong(2)
                    )
            );
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31; // xxxxxxxxxxx-- xxxxxxx-------
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

       //     String seq= BinaryBlocksToString(blocks);
 //           System.out.println("seq: " + seq + " shiftingLength: " + shiftingLength + " nucleotideLength: " + nucleotideLength + " residueLength: " + residueLength);

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

         //   System.out.println("relativeShiftSize: " + relativeShiftSize + " j: " + j);
            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
            //    String rightBlocksString = BinaryBlocksToString(rightBlocks);
             //   String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
            //        String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

            //    String mergedKmer= BinaryBlocksToString(newBlocks);

 //               System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        /**
         *
         */
        public void tmpKmerRandomizer() throws Exception {
            if (tmpReflexivKmerExtendList.size() != 0) {
                for (int i = 0; i < tmpReflexivKmerExtendList.size(); i++) {
                    singleKmerRandomizer(tmpReflexivKmerExtendList.get(i));
                }
            }
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    /**
     *
     */


    class DSFilterForkSubKmer implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();
//        Tuple2<String, Tuple4<Integer, String, Integer, Integer>> HighCoverKmer=null;
//                new Tuple2<String, Tuple4<Integer, String, Integer, Integer>>("",
        //                       new Tuple4<Integer, String, Integer, Integer>(0, "", 0, 0));

        public Iterator<Row> call(Iterator<Row> s) {
            while (s.hasNext()) {
                Row subKmer = s.next();
                if (HighCoverageSubKmer.size() == 0) {
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), -1)
                    );
                } else {
                    if (subKmerSlotComparator(subKmer.getSeq(0), HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(0)) == true) {
                        if (subKmer.getInt(3) > HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getInt(3)) {
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), param.subKmerSize)
                            );
                        } else if (subKmer.getInt(3) == HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getInt(3)) {
                            if (subKmer.getLong(2) > HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2)) {
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), param.subKmerSize)
                                );
                            } else {
                                /**
                                 * can be optimized
                                 */
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), param.subKmerSize)
                                );
                            }
                        } else {
                            subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), param.subKmerSize)
                            );
                        }
                    } else {
                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), subKmer.getInt(3), -1)
                        );
                    }
                }
            }

            return HighCoverageSubKmer.iterator();
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    /**
     *  choose one kmer from a fork with higher coverage.
     */


    class DSFilterForkSubKmerWithErrorCorrection2 implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();
//        Tuple2<String, Tuple4<Integer, String, Integer, Integer>> HighCoverKmer=null;
//                new Tuple2<String, Tuple4<Integer, String, Integer, Integer>>("",
        //                       new Tuple4<Integer, String, Integer, Integer>(0, "", 0, 0));

        public Iterator<Row> call(Iterator<Row> s) {
            while (s.hasNext()) {
                Row subKmer = s.next();
                int reflexivMarker = getReflexivMarker(subKmer.getLong(1));
                int leftMarker = getLeftMarker(subKmer.getLong(1));
                int rightMarker = getRightMarker(subKmer.getLong(1));

                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray((long[]) subKmer.get(0));

                if (HighCoverageSubKmer.size() == 0) {
                    long attribute = buildingAlongFromThreeInt(reflexivMarker,leftMarker, -1-rightMarker);
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                    );
                } else {
                    int highestLeftMarker = getLeftMarker(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(1));
                    if (subKmerSlotComparator(subKmer.getSeq(0), HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(0)) == true) {
                        if (leftMarker > highestLeftMarker) {
                            if (highestLeftMarker <= param.minErrorCoverage && leftMarker >= 2 * highestLeftMarker) {
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, leftMarker, -1-leftMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            } else {
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, leftMarker, currentSubKmerSize+10);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            }
                        } else if (leftMarker == highestLeftMarker) {
                            if (subKmer.getLong(2) > HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2)) {
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, leftMarker, currentSubKmerSize+10);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            } else {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                                reflexivMarker=getReflexivMarker(subKmer.getLong(1));
                                leftMarker=getLeftMarker(subKmer.getLong(1));
                              //  rightMarker=getRightMarker(subKmer.getLong(1));
                                currentSubKmerSize=currentKmerSizeFromBinaryBlockArray((long[])subKmer.get(0));
                                long attribute = buildingAlongFromThreeInt(reflexivMarker,leftMarker,currentSubKmerSize+10);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            }
                        } else {
                            if (leftMarker <= param.minErrorCoverage && highestLeftMarker >= 2 * leftMarker) {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                                reflexivMarker=getReflexivMarker(subKmer.getLong(1));
                                leftMarker=getLeftMarker(subKmer.getLong(1));
                                rightMarker=getRightMarker(subKmer.getLong(1));
                               // currentSubKmerSize=currentKmerSizeFromBinaryBlockArray((long[])subKmer.get(0));
                                long attribute = buildingAlongFromThreeInt(reflexivMarker,leftMarker,-1-rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            } else {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                                reflexivMarker=getReflexivMarker(subKmer.getLong(1));
                                leftMarker=getLeftMarker(subKmer.getLong(1));
                              //  rightMarker=getRightMarker(subKmer.getLong(1));
                                currentSubKmerSize=currentKmerSizeFromBinaryBlockArray((long[])subKmer.get(0));
                                long attribute = buildingAlongFromThreeInt(reflexivMarker,leftMarker,currentSubKmerSize+10);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            }
                        }
                    } else {
                        long attribute = buildingAlongFromThreeInt(reflexivMarker, leftMarker, -1-leftMarker);
                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                        );
                    }
                }
            }

            return HighCoverageSubKmer.iterator();
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 31) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

    }

    class DSFilterForkReflectedSubKmer implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();
        Integer HighCoverLastCoverage = 0;
//        Row HighCoverKmer=null;
//                new Row("",
        //                       new Tuple4<Integer, Long, Integer, Integer>(0, "", 0, 0));

        public Iterator<Row> call(Iterator<Row> s) {
            while (s.hasNext()) {
                Row subKmer = s.next();
                if (HighCoverageSubKmer.size() == 0) {
                    HighCoverLastCoverage = subKmer.getInt(3);
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), -1, subKmer.getInt(4))
                    );
                } else {
                    if (subKmerSlotComparator(subKmer.getSeq(0), HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(0)) == true) {
                        if (subKmer.getInt(3) > HighCoverLastCoverage) {
                            HighCoverLastCoverage = subKmer.getInt(3);
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), param.subKmerSize, subKmer.getInt(4))
                            );
                        } else if (subKmer.getInt(3) == HighCoverLastCoverage) {
                            int subKmerFirstSuffixLength = Long.SIZE / 2 - (Long.numberOfLeadingZeros(subKmer.getLong(2)) / 2 + 1);
                            int HighCoverageSubKmerFirstSuffixLength = Long.SIZE / 2 - ((Long.numberOfLeadingZeros(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2))) / 2 + 1);
                            Long subKmerFirstSuffix = subKmer.getLong(2) >>> 2 * (subKmerFirstSuffixLength - 1);
                            Long HighCoverageSubKmerFirstSuffix = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2) >>> 2 * (HighCoverageSubKmerFirstSuffixLength);

                            if (subKmerFirstSuffix.compareTo(HighCoverageSubKmerFirstSuffix) > 0) {
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), param.subKmerSize, subKmer.getInt(4))
                                );
                            } else {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1); // re assign
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), param.subKmerSize, subKmer.getInt(4))
                                );
                            }
                        } else {
                            subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);
                            HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                    RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), param.subKmerSize, subKmer.getInt(4))
                            );
                        }
                    } else {
                        HighCoverLastCoverage = subKmer.getInt(3);
                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getSeq(0), subKmer.getInt(1), subKmer.getLong(2), -1, subKmer.getInt(4))
                        );
                    }
                }
            }

            return HighCoverageSubKmer.iterator();
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    class DSFilterForkReflectedSubKmerWithErrorCorrection2 implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> HighCoverageSubKmer = new ArrayList<Row>();
        Integer HighCoverLastCoverage = 0;
//        Row HighCoverKmer=null;
//                new Tuple2<Long, Tuple4<Integer, Long, Integer, Integer>>("",
        //                       new Tuple4<Integer, Long, Integer, Integer>(0, "", 0, 0));

        public Iterator<Row> call(Iterator<Row> s) {
            while (s.hasNext()) {
                Row subKmer = s.next();
                int reflexivMarker = getReflexivMarker(subKmer.getLong(1));
                int leftMarker = getLeftMarker(subKmer.getLong(1));
                int rightMarker = getRightMarker(subKmer.getLong(1));

                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray((long[]) subKmer.get(0));


                if (HighCoverageSubKmer.size() == 0) {
                    HighCoverLastCoverage = leftMarker;
                    long attribute = buildingAlongFromThreeInt(reflexivMarker,-1-leftMarker, rightMarker);
                    HighCoverageSubKmer.add(
                            RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                    );
                } else {
                    int highestLeftMarker = getLeftMarker(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(1));
                    if (subKmerSlotComparator(subKmer.getSeq(0), HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getSeq(0)) == true) {
                        if (leftMarker > HighCoverLastCoverage) {
                            if (HighCoverLastCoverage <= param.minErrorCoverage && leftMarker >= 2 * HighCoverLastCoverage) {
                                HighCoverLastCoverage = leftMarker;
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, -1-leftMarker, rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            } else {
                                HighCoverLastCoverage = leftMarker;
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, currentSubKmerSize+10, rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0), attribute, subKmer.getLong(2))
                                );
                            }
                        } else if (leftMarker == HighCoverLastCoverage) {
                            int subKmerFirstSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(subKmer.getLong(2)) / 2 + 1);
                            int HighCoverageSubKmerFirstSuffixLength = Long.SIZE / 2 - ((Long.numberOfTrailingZeros(HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2))) / 2 + 1);
                            Long subKmerFirstSuffix = subKmer.getLong(2) >>> 2 * (32-subKmerFirstSuffixLength);
                            Long HighCoverageSubKmerFirstSuffix = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1).getLong(2) >>> 2 * (32-HighCoverageSubKmerFirstSuffixLength);

                            if (subKmerFirstSuffix.compareTo(HighCoverageSubKmerFirstSuffix) > 0) {
                                long attribute = buildingAlongFromThreeInt(reflexivMarker, currentSubKmerSize+10, rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0),
                                                attribute, subKmer.getLong(2))
                                );
                            } else {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1); // re assign
                                reflexivMarker=getReflexivMarker(subKmer.getLong(1));
                               // leftMarker=getLeftMarker(subKmer.getLong(1));
                                rightMarker=getRightMarker(subKmer.getLong(1));
                                currentSubKmerSize=currentKmerSizeFromBinaryBlockArray((long[])subKmer.get(0));

                                long attribute= buildingAlongFromThreeInt(reflexivMarker,currentSubKmerSize+10, rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0),
                                                attribute, subKmer.getLong(2))
                                );
                            }
                        } else {
                            if (leftMarker <= param.minErrorCoverage && HighCoverLastCoverage >= 2 * leftMarker) {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);

                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0),
                                                subKmer.getLong(1), subKmer.getLong(2))
                                );
                            } else {
                                subKmer = HighCoverageSubKmer.get(HighCoverageSubKmer.size() - 1);

                                reflexivMarker=getReflexivMarker(subKmer.getLong(1));
                                //leftMarker=getLeftMarker(subKmer.getLong(1));
                                rightMarker=getRightMarker(subKmer.getLong(1));
                                currentSubKmerSize=currentKmerSizeFromBinaryBlockArray((long[])subKmer.get(0));

                                long attribute = buildingAlongFromThreeInt(reflexivMarker, currentSubKmerSize+10, rightMarker);
                                HighCoverageSubKmer.set(HighCoverageSubKmer.size() - 1,
                                        RowFactory.create(subKmer.getSeq(0),
                                                attribute, subKmer.getLong(2))
                                );
                            }
                        }
                    } else {
                        HighCoverLastCoverage = leftMarker;
                        long attribute = buildingAlongFromThreeInt(reflexivMarker,-1-leftMarker, rightMarker);

                        HighCoverageSubKmer.add(
                                RowFactory.create(subKmer.getSeq(0),
                                        attribute, subKmer.getLong(2))
                        );
                    }
                }
            }

            return HighCoverageSubKmer.iterator();
        }

        private boolean subKmerSlotComparator(Seq a, Seq b) {
            for (int i = 0; i < a.length(); i++) {
                if (!a.apply(i).equals(b.apply(i))) {
                    return false;
                }
            }

            return true;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 31) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    class DSForwardSubKmerExtraction2 implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> TupleList = new ArrayList<Row>();
        Long suffixBinary;
        long[] prefixBinarySlot;
        Row kmerTuple;
        int currentSubKmerSize;
        int currentSubKmerResidue;
        int currentSubKmerBlock;

        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {
                kmerTuple = s.next();
                /**
                 * normal Sub-kmer
                 *        Kmer      ATGCACGTTATG
                 *        Sub-Kmer  ATGCACGTTAT         marked as Integer 1 in Tuple2
                 *        Left      -----------G
                 */
                currentSubKmerSize= currentKmerSizeFromBinaryBlockArray((long[])kmerTuple.get(0));
                currentSubKmerResidue = (currentSubKmerSize-1)%31 +1;
                currentSubKmerBlock = (currentSubKmerSize-1)/31+1;


                if (currentSubKmerResidue == 31) { // currentSubKmerBlock == previousSubKmerBlock -1
                    prefixBinarySlot = new long[currentSubKmerBlock];

                    suffixBinary = ((long[]) kmerTuple.get(0))[currentSubKmerBlock-1]; // last block XC---------- C marker keep it
                    for (int i = 0; i < currentSubKmerBlock-1; i++) {
                        prefixBinarySlot[i] = ((long[]) kmerTuple.get(0))[i];
                    }
                } else { // currentSubKmerBlock == previousSubKmerBlock
                    prefixBinarySlot = new long[currentSubKmerBlock];

                    suffixBinary = (((long[]) kmerTuple.get(0))[currentSubKmerBlock-1]
                            >>> (2*(32-currentSubKmerResidue)))
                            & 3L;
                    for (int i = 0; i < param.subKmerBinarySlots - 1; i++) {
                        prefixBinarySlot[i] = ((long[]) kmerTuple.get(0))[i];
                    }
                    prefixBinarySlot[currentSubKmerBlock - 1] = ((long[]) kmerTuple.get(0))[currentSubKmerBlock - 1] >>> 2;
                }

                long attribute = buildingAlongFromThreeInt(1, kmerTuple.getInt(1), kmerTuple.getInt(1));

                TupleList.add(
                        RowFactory.create(prefixBinarySlot, attribute, suffixBinary)
                );
            }

            return TupleList.iterator();
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most
            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2 -1;

            kmerSize+=lastMers;
            return kmerSize;

        }


        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }


    /**
     *
     */


    class DSReflectedSubKmerExtractionFromForward2 implements MapPartitionsFunction<Row, Row>, Serializable {
        List<Row> TupleList = new ArrayList<Row>();
        Long suffixBinary;
        long[] prefixBinarySlot;
        Row kmerTuple;
     //   int shift = (2 * (param.subKmerSizeResidue - 1));
        Long maxSubKmerResdueBinary ;
        Long maxSubKmerBinary = ~((~0L) << 2 * 31);

        int currentSubKmerSize;
        int currentSubKmerResidue;
        int currentSubKmerBlock;

        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {
                kmerTuple = s.next();

                currentSubKmerSize= currentKmerSizeFromBinaryBlockArray((long[])kmerTuple.get(0));
                currentSubKmerResidue = (currentSubKmerSize-1)%31 +1;
                currentSubKmerBlock = (currentSubKmerSize-1)/31+1;
                maxSubKmerResdueBinary=  ((~0L) << 2 * (32-currentSubKmerResidue));

                long[] prefixBinarySlot = new long[currentSubKmerBlock];

                /**
                 * reflected Sub-kmer
                 *        Kmer      ATGCACGTTATG
                 *        Sub-Kmer  ATGCACGTTAT         marked as Integer 1 in Tuple2
                 *        Left      -----------G
                 */
                // suffixBinary = 3L << shift;
                suffixBinary = (Long) kmerTuple.getSeq(0).apply(0) >>> 2*(32-1);
                suffixBinary <<= 2*(32-1);  // ---------xx -> xx000000000
                //  suffixBinary >>>= shift;
                suffixBinary |= (1L << 2*(32-1-1)); // add C marker in the front 0100 = 4L

                long transmitBit1 = (Long) kmerTuple.getSeq(0).apply(currentSubKmerBlock - 1) >>> 2 * (32 - 1);   // xx-------------
                prefixBinarySlot[currentSubKmerBlock - 1] = ((Long) kmerTuple.getSeq(0).apply(currentSubKmerBlock - 1) & maxSubKmerResdueBinary )<< 2;
                //prefixBinarySlot[currentSubKmerBlock - 1] &= maxSubKmerResdueBinary;
                prefixBinarySlot[currentSubKmerBlock - 1] |= kmerTuple.getLong(2)>>> 2*(currentSubKmerResidue-1); // xx01-------- -> ----------xx01

                for (int i = currentSubKmerBlock - 2; i >= 0; i--) {
                    long transmitBit2 = (Long) kmerTuple.getSeq(0).apply(i) >>> 2*(32-1);

                    prefixBinarySlot[i] = (Long) kmerTuple.getSeq(0).apply(i) << 2;
                 //   prefixBinarySlot[i] &= maxSubKmerBinary;
                    prefixBinarySlot[i] |= (transmitBit1 << 1*2); // ----------xx -> ---------xx--

                    transmitBit1 = transmitBit2;
                }



                long attribute = onlyChangeReflexivMarker(kmerTuple.getLong(1), 2);

                TupleList.add(
                        RowFactory.create(prefixBinarySlot, attribute, suffixBinary)
                );
            }

            return TupleList.iterator();
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    class DSkmerRandomReflection implements MapPartitionsFunction<Row, Row>, Serializable {
        /* 0 stands for forward sub-kmer */
        /* 1 stands for reflexiv sub-kmer */
        private int randomReflexivMarker = 2;

        List<Row> reflexivKmerConcatList = new ArrayList<Row>();
        Row kmerTuple;
        long maxSubKmerResidueBinary = ~((~0L) << 2 * param.subKmerSizeResidue);
        long maxSubKmerBinary = ~((~0L) << 2 * 31);

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while (s.hasNext()) {
                kmerTuple = s.next();

                singleKmerRandomizer(kmerTuple);
            }

            return reflexivKmerConcatList.iterator();
        }

        public void singleKmerRandomizer(Row currentSubKmer) throws Exception {

            if (getReflexivMarker(currentSubKmer.getLong(1)) == 1) {
                /**
                 * 00000000000000110010111010010   Long.SIZE
                 * --------------C-G-G-G-T-C-A-G   Long.SIZE - (Long.numberOfLeadingZeros / 2 + 1)
                 * --------------^-Length marker
                 */

                int currentSuffixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1); // xx01-------
                long[] newReflexivSubKmer; //= new long[param.subKmerBinarySlots];
                long newReflexivLong;

            //    String seq= BinaryBlocksToString((long[])currentSubKmer.get(0));
                long[] reflexivKmerArray = new long[1];
                reflexivKmerArray[0]=currentSubKmer.getLong(2);
            //    String reflexivKmerString= BinaryBlocksToString(reflexivKmerArray);
                int leftMarker = getLeftMarker(currentSubKmer.getLong(1));
                int rightMarker = getRightMarker(currentSubKmer.getLong(1));
                int reflexivMarker = getReflexivMarker(currentSubKmer.getLong(1));
              //  System.out.println("Seq: " + seq + " reflexivMarker: " + reflexivMarker + " leftMarker: " + leftMarker + " rightMarker: " + rightMarker + " extension: " + reflexivKmerString);

                if (randomReflexivMarker == 2) {

                    newReflexivSubKmer = leftShiftArray((long[])currentSubKmer.get(0), currentSuffixLength);
             //       String new1 = BinaryBlocksToString(newReflexivSubKmer);
               //     System.out.println("leftShiftArray: " + new1);
                    long[] newReflexivLongArray = leftShiftOutFromArray((long[])currentSubKmer.get(0), currentSuffixLength);
                    newReflexivLong = newReflexivLongArray[0];

                    long[] suffixArray = new long[1];
                    suffixArray[0]= currentSubKmer.getLong(2);
                    newReflexivSubKmer = combineTwoLongBlocks(newReflexivSubKmer, suffixArray);
            //        String new2 = BinaryBlocksToString(newReflexivSubKmer);
                 //   System.out.println("combineTwoLongBlocks: " + new2);

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

               //     String newSeq = BinaryBlocksToString(newReflexivSubKmer);
                    long[] newReflexivKmerArray = new long[1];
                    newReflexivKmerArray[0]=newReflexivLong;
             //       String newReflexivKmerString = BinaryBlocksToString(newReflexivKmerArray);

                //    System.out.println("new Seq: " + newSeq + " extension: " + newReflexivKmerString);

                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLong)
                    );

                } else {
                    reflexivKmerConcatList.add(currentSubKmer);
                }
            } else { /* currentSubKmer._2._1() == 2 */
                int currentPrefixLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(currentSubKmer.getLong(2)) / 2 + 1);
                long[] newReflexivSubKmer; // = new long[param.subKmerBinarySlots];
                long newReflexivLong;
                int currentSubKmerSize= currentKmerSizeFromBinaryBlockArray((long[])currentSubKmer.get(0));

           //     String seq= BinaryBlocksToString((long[])currentSubKmer.get(0));
              //  System.out.println("Seq: " + seq + " attribute: " + currentSubKmer.getLong(1)  + " extension: " + currentSubKmer.getLong(2));

                if (randomReflexivMarker == 2) {
                    reflexivKmerConcatList.add(currentSubKmer);
                } else { /* randomReflexivMarker == 1 */

                    int rightShiftRemain = currentSubKmerSize-currentPrefixLength;
                    long[] rightShiftRemainBlocks = leftShiftOutFromArray((long[])currentSubKmer.get(0), rightShiftRemain);
                    long[] prefixArray = new long[1];
                    prefixArray[0]=currentSubKmer.getLong(2);
              //      String prefixArrayString = BinaryBlocksToString(prefixArray);
              //      String rightShiftRemainBlocksString = BinaryBlocksToString(rightShiftRemainBlocks);
                //    System.out.println("prefix: " + prefixArrayString + " rightsHIFTremainBlocks: " + rightShiftRemainBlocksString + " rightShiftRemain: " + rightShiftRemain + " currentSubKmerSize: "+ currentSubKmerSize + " currentPrefixLength: " + currentPrefixLength);

                    newReflexivSubKmer = combineTwoLongBlocks(prefixArray, rightShiftRemainBlocks);

                    newReflexivLong = (leftShiftArray((long[])currentSubKmer.get(0), rightShiftRemain))[0];

                    long attribute = onlyChangeReflexivMarker(currentSubKmer.getLong(1), randomReflexivMarker);

              //      String newseq= BinaryBlocksToString(newReflexivSubKmer);
                 //   System.out.println("new Seq: "  + newseq + " attribute: " + attribute + " extention:" + newReflexivLong);
                    reflexivKmerConcatList.add(
                            RowFactory.create(newReflexivSubKmer, attribute, newReflexivLong)
                    );
                }

            }

            /* an action of randomization */

            if (randomReflexivMarker == 1) {
                randomReflexivMarker = 2;
            } else { /* randomReflexivMarker == 2 */
                randomReflexivMarker = 1;
            }
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength - 1) % 31 + 1;
            int leftVacancy = 31 - leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength + rightNucleotideLength - 1) / 31 + 1;
            long[] newBlocks = new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy == 0) { // left last block is a perfect block
                for (int i = 0; i < leftBlocks.length; i++) {
                    newBlocks[i] = leftBlocks[i];
                }

                newBlocks[leftBlocks.length - 1] &= (~0L << 2); // remove the last block's C marker

                for (int j = leftBlocks.length; j < combinedBlockSize; j++) {
                    newBlocks[j] = rightBlocks[j - leftBlocks.length];
                }
            } else {
             //   String rightBlocksString = BinaryBlocksToString(rightBlocks);
             //   String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i = 0; i < leftBlocks.length; i++) {
                    newBlocks[i] = leftBlocks[i];
                }

                newBlocks[leftBlocks.length - 1] &= (~0L << 2 * (leftVacancy + 1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length - 1] |= (shiftOutBlocks[0] >>> 2 * (leftRelativeNTLength));
                if (leftBlocks.length < combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length - 1] &= (~0L << 2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k = 0; // rightBlocksLeftShifted index
                for (int j = leftBlocks.length; j < combinedBlockSize; j++) { // including the last blocks.
                    newBlocks[j] = rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray = new long[1];
                    rightBlocksLeftShiftedArray[0] = rightBlocksLeftShifted[k - 1];
               //     String rightShift = BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

              //  String mergedKmer = BinaryBlocksToString(newBlocks);

                //System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    /**
     *
     */

    class DSshortBranchRemovalRight implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList =new ArrayList<Row>();
        int maxKmerSize = param.kmerListInt[param.kmerListInt.length-1];
        Row lastSubKmer;

        private Row rightLongAndShortBranchCorrection(Row subKmer, boolean change) throws Exception{
            long[] subKmerArray = seq2array(subKmer.getSeq(0));
            long[] extensionArray =seq2array(subKmer.getSeq(2));
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getRightMarker(subKmer.getLong(1))>0){
                    subKmerArray=reverseBinaryBlocks(subKmerArray); // change back reversed subKmer

                    int rightSideLength = maxKmerSize + 3 - getRightMarker(subKmer.getLong(1)) + 1;
                    long[] rightResidue = leftShiftOutFromArray(extensionArray, rightSideLength);  // 3333311111111111111 -> 33333
                    long[] newExtension = leftShiftArray(extensionArray, rightSideLength);          // 3333311111111111111 -> 11111111111111
                    long[] newSubKmer = combineTwoLongBlocks(subKmerArray,rightResidue);              // 2222222 + 33333 -> 222222233333
                    newExtension=combineTwoLongBlocks(newExtension,newSubKmer);                        // 1111111111111 + 222222233333 -> 1111111111111222222233333
                    newSubKmer = leftShiftArray(newSubKmer, rightSideLength);                        // 222222233333 -> 22222 22233333
                    newExtension = leftShiftOutFromArray(newExtension, totalLength-maxKmerSize +1);   // 1111111111111222222233333 -> 111111111111122222

                    long attribute;
                    if (change){
                        attribute = buildingAlongFromThreeInt(2, getLeftMarker(subKmer.getLong(1)),-1);
                    }else {
                        attribute = onlyChangeReflexivMarker(subKmer.getLong(1), 2);
                    }

                    return RowFactory.create(newSubKmer, attribute, newExtension);
                }else{
                    return subKmer;
                }
            }else{
                if (getLeftMarker(subKmer.getLong(1))<-1 && getRightMarker(subKmer.getLong(1))<-1){
                    subKmerArray=reverseBinaryBlocks(subKmerArray); // change back reversed subKmer

                    long[] combinedKmerArray;
                    if (getReflexivMarker(subKmer.getLong(1))==1){
                        combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                    }else{ // reflexed
                        combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                    }
                    /**
                     *         A----------  This K-mer has been removed in kmer preparation step
                     *    ----XA--------- A is the mutation X is one Kmer over the muation.
                     */
                    // -----
                    int rightSideLength = -getRightMarker(subKmer.getLong(1))-1 ;   // change back to normal
                    long[] newReflexivKmer = leftShiftArray(combinedKmerArray,totalLength-rightSideLength);
                    long[] newSubKmer = leftShiftOutFromArray(combinedKmerArray,totalLength-rightSideLength);

                    long newReflexivMarker = onlyChangeReflexivMarker(subKmer.getLong(1), 1);
                    return RowFactory.create(
                            newSubKmer,newReflexivMarker,newReflexivKmer);
                }else{
                    return subKmer;
                }
            }
        }

        private Row rightLongAndShortBranchCorrectionArray(long[] subKmerArray, long attr, long[] extensionArray, boolean change) throws Exception{
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getRightMarker(attr)>0){
                    subKmerArray=reverseBinaryBlocks(subKmerArray); // change back reversed subKmer

                    int rightSideLength = maxKmerSize + 3 - getRightMarker(attr) + 1;
                    long[] rightResidue = leftShiftOutFromArray(extensionArray, rightSideLength);  // 3333311111111111111 -> 33333
                    long[] newExtension = leftShiftArray(extensionArray, rightSideLength);          // 3333311111111111111 -> 11111111111111
                    long[] newSubKmer = combineTwoLongBlocks(subKmerArray,rightResidue);              // 2222222 + 33333 -> 222222233333
                    newExtension=combineTwoLongBlocks(newExtension,newSubKmer);                        // 1111111111111 + 222222233333 -> 1111111111111222222233333
                    newSubKmer = leftShiftArray(newSubKmer, rightSideLength);                        // 222222233333 -> 22222 22233333
                    newExtension = leftShiftOutFromArray(newExtension, totalLength-maxKmerSize +1);   // 1111111111111222222233333 -> 111111111111122222

                    if (change){
                        attr=buildingAlongFromThreeInt(2, getLeftMarker(attr), -1);
                    }else {
                        attr = onlyChangeReflexivMarker(attr, 2);
                    }

                    return RowFactory.create(newSubKmer, attr, newExtension);
                }else{
                    return RowFactory.create(subKmerArray, attr, extensionArray);
                }
            }else {
                if (getLeftMarker(attr) < -1 && getRightMarker(attr) < -1) {
                    subKmerArray=reverseBinaryBlocks(subKmerArray); // change back reversed subKmer

                    long[] combinedKmerArray;
                    if (getReflexivMarker(attr) == 1) {
                        combinedKmerArray = combineTwoLongBlocks(subKmerArray, extensionArray);
                    } else { // reflected
                        combinedKmerArray = combineTwoLongBlocks(extensionArray, subKmerArray);
                    }
                    /**
                     *         A----------  This K-mer has been removed in kmer preparation step
                     *    ----XA--------- A is the mutation X is one Kmer over the muation.
                     */
                    // -----
                    int rightSideLength = -getRightMarker(attr) - 1;   // change back to normal
                    long[] newReflexivKmer = leftShiftArray(combinedKmerArray, totalLength - rightSideLength);
                    long[] newSubKmer = leftShiftOutFromArray(combinedKmerArray, totalLength - rightSideLength);

                    long newReflexivMarker = onlyChangeReflexivMarker(attr, 1);
                    return RowFactory.create(
                            newSubKmer, newReflexivMarker, newReflexivKmer);
                } else {
                    return RowFactory.create(
                            subKmerArray, attr, extensionArray);
                }
            }
        }

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while(s.hasNext()) {
                Row subKmer = s.next();
                if (lastSubKmer==null){
                    lastSubKmer=subKmer;
                    continue;
                }

                long[] subKmerArray = seq2array(subKmer.getSeq(0));
                long[] extensionArray = seq2array(subKmer.getSeq(2));
                int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
                int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
                int totalLength = subKmerLength + extensionLength;

                if (totalLength >= 2*maxKmerSize){
                    if (getRightMarker(subKmer.getLong(1))>0) {
                        long[] lastSubKmerArray = seq2array(lastSubKmer.getSeq(0));
                        long[] lastExtensionArray = seq2array(lastSubKmer.getSeq(2));
                        int lastSubKmerLength = currentKmerSizeFromBinaryBlockArray(lastSubKmerArray);
                        int lastExtensionLength = currentKmerSizeFromBinaryBlockArray(lastExtensionArray);
                        int lastTotalLength = lastSubKmerLength + lastExtensionLength;

                        long attribute = onlyChangeReflexivMarker(subKmer.getLong(1), 2);

                        if (lastTotalLength < 2 * maxKmerSize) {
                            if (getLeftMarker(lastSubKmer.getLong(1)) < -1 && getRightMarker(lastSubKmer.getLong(1)) < -1) {
                                if (dynamicSubKmerComparator(subKmer.getSeq(0), lastSubKmer.getSeq(0)) == true) {
                                    Row newSubKmer = rightLongAndShortBranchCorrectionArray(subKmerArray, attribute, extensionArray, true);

                               //     String subKmerString= BinaryBlocksToString(subKmerArray);
                                //    String extensionString= BinaryBlocksToString(extensionArray);
                                 //   String newSubKmerString= BinaryBlocksToString((long[])newSubKmer.get(0));
                                  //  String newExtensionString= BinaryBlocksToString((long[])newSubKmer.get(2));
                             //       System.out.println("right 1 before: " + subKmerString + " extension: " + extensionString + " leftMarker: " + getLeftMarker(subKmer.getLong(1)) + " rightMarker: " + getRightMarker(subKmer.getLong(1)) + " reflexivMarker: " + getReflexivMarker(subKmer.getLong(1)) + " after: " + newSubKmerString + " extension: " + newExtensionString
                              //              + " newLeftMarker: " + getLeftMarker(newSubKmer.getLong(1)) + " newRightMarker: " + getRightMarker(newSubKmer.getLong(1)) + " newReflexivMarker: " + getReflexivMarker(newSubKmer.getLong(1))
                               //     );

                                    kmerList.add(rightLongAndShortBranchCorrection(lastSubKmer, false));
                                    kmerList.add(newSubKmer);
                                    lastSubKmer = null;

                                } else {
                                    Row newSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                                    kmerList.add(newSubKmer);
                                    lastSubKmer = subKmer;
                                }
                            } else {
                                Row newSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                                kmerList.add(newSubKmer);
                                lastSubKmer = subKmer;
                            }
                        } else {
                            Row newSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                            kmerList.add(newSubKmer);
                            lastSubKmer = subKmer;
                        }
                    }else{
                        Row newSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                        kmerList.add(newSubKmer);
                        lastSubKmer = subKmer;
                    }
                }else{
                    if (getLeftMarker(subKmer.getLong(1)) < -1 && getRightMarker(subKmer.getLong(1)) < -1) {
                        if (getRightMarker(lastSubKmer.getLong(1)) > 0) {
                            long[] lastSubKmerArray = seq2array(lastSubKmer.getSeq(0));
                            long[] lastExtensionArray = seq2array(lastSubKmer.getSeq(2));
                            int lastSubKmerLength = currentKmerSizeFromBinaryBlockArray(lastSubKmerArray);
                            int lastExtensionLength = currentKmerSizeFromBinaryBlockArray(lastExtensionArray);
                            int lastTotalLength = lastSubKmerLength + lastExtensionLength;

                            long attribute = onlyChangeReflexivMarker(lastSubKmer.getLong(1), 2);

                            if (lastTotalLength >=2*maxKmerSize){
                                if (dynamicSubKmerComparator(subKmer.getSeq(0), lastSubKmer.getSeq(0)) == true) {

                                    Row newLastSubKmer = rightLongAndShortBranchCorrectionArray(lastSubKmerArray, attribute, lastExtensionArray, true);

                                //    String subKmerString= BinaryBlocksToString(lastSubKmerArray);
                                 //   String extensionString= BinaryBlocksToString(lastExtensionArray);
                                 //   String newSubKmerString= BinaryBlocksToString((long[])newLastSubKmer.get(0));
                                  //  String newExtensionString= BinaryBlocksToString((long[])newLastSubKmer.get(2));
                              //      System.out.println("right 2 before: " + subKmerString + " extension: " + extensionString + " leftMarker: " + getLeftMarker(lastSubKmer.getLong(1)) + " rightMarker: " + getRightMarker(lastSubKmer.getLong(1)) + "reflexivMarrker: " + getReflexivMarker(lastSubKmer.getLong(1)) +  " after: " + newSubKmerString + " extension: " + newExtensionString
                              //              + " newLeftMarker: " + getLeftMarker(newLastSubKmer.getLong(1)) + " newRightMarker: " + getRightMarker(newLastSubKmer.getLong(1)) + " newReflexivMarker: " + getReflexivMarker(newLastSubKmer.getLong(1))
                              //      );

                                    kmerList.add(newLastSubKmer);
                                    kmerList.add(rightLongAndShortBranchCorrection(subKmer, false));
                                    lastSubKmer=null;
                                }else{
                                    Row newLastSubKmer = rightLongAndShortBranchCorrectionArray(lastSubKmerArray, attribute, lastExtensionArray, false);
                                    kmerList.add(newLastSubKmer);
                                    lastSubKmer=subKmer;
                                }
                            }else{
                                Row newLastSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                                kmerList.add(newLastSubKmer);
                                lastSubKmer=subKmer;
                            }
                        } else {
                            Row newLastSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                            kmerList.add(newLastSubKmer);
                            lastSubKmer=subKmer;
                        }
                    } else {
                        //  kmerList.add(lastSubKmer); // does not need to be prepared
                        Row newLastSubKmer = rightLongAndShortBranchCorrection(lastSubKmer, false);
                        kmerList.add(newLastSubKmer);
                        lastSubKmer=subKmer;
                    }
                }
            }

            if (lastSubKmer!=null){
                kmerList.add(rightLongAndShortBranchCorrection(lastSubKmer,false));
            }

            return kmerList.iterator();
        }
        private long[] reverseBinaryBlocks(long[] blocks){
            int length = currentKmerSizeFromBinaryBlockArray(blocks);
            int blockNumber= blocks.length;
            long[] newBlocks= new long[blockNumber];
            int reverseIndex;
            int reverseBlockIndex;
            int relativeReverseIndex;

            int forwardBlockIndex;

            long twoBits;
            for (int i=0; i<length;i++){
                reverseIndex=length-i-1;
                reverseBlockIndex=reverseIndex/31;
                relativeReverseIndex=reverseIndex%31;

                forwardBlockIndex=i/31;

                twoBits=blocks[reverseBlockIndex] >>>2*(31-relativeReverseIndex);
                twoBits&=3L;

                newBlocks[forwardBlockIndex]|=twoBits;
                newBlocks[forwardBlockIndex] <<=2;
            }
            int lastBlockShift=31-(length-1)%31-1;
            newBlocks[newBlocks.length-1] <<=2*lastBlockShift;
            newBlocks[newBlocks.length - 1] |= (1L << 2 * (lastBlockShift));


            return newBlocks;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

          //  String arrayAString = BinaryBlocksToString(arrayA);
         //   String arrayBString = BinaryBlocksToString(arrayB);

            //     System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);

            if (aLength>=bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                if (Arrays.equals(shorterVersion, arrayB)){
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31; // xxxxxxxxxxx-- xxxxxxx-------
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

        //    String seq= BinaryBlocksToString(blocks);
            //           System.out.println("seq: " + seq + " shiftingLength: " + shiftingLength + " nucleotideLength: " + nucleotideLength + " residueLength: " + residueLength);

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            //   System.out.println("relativeShiftSize: " + relativeShiftSize + " j: " + j);
            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            if (shiftingLength<=0){ // return an empty array
                long[] a = new long[1];
                a[0]= (1L << 2*31); // 01xxxxxxxxxx
                return a;
            }

            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
            //    String rightBlocksString = BinaryBlocksToString(rightBlocks);
            //    String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
             //       String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

            //    String mergedKmer= BinaryBlocksToString(newBlocks);

                //               System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            if (suffix0s >=63){
                suffix0s=62;
            }
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

    }


    class DSShortBranchRemovalLeftWhilePreparingForRight implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList = new ArrayList<Row>();
        int maxKmerSize = param.kmerListInt[param.kmerListInt.length-1];
        int marker=0;
        Row lastSubKmer;

        private Row rightPreparation (Row subKmer) throws Exception {
            long[] subKmerArray = seq2array(subKmer.getSeq(0));
            long[] extensionArray =seq2array(subKmer.getSeq(2));
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getRightMarker(subKmer.getLong(1))>0){
                    long[] combinedKmerArray;
                    if (getReflexivMarker(subKmer.getLong(1))==1){
                        combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                    }else{ // reflexed
                        combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                    }

                    int rightSideLength = maxKmerSize + 3 - getRightMarker(subKmer.getLong(1)) +1 ; // branching point
                    long[] rightResidue = leftShiftArray(combinedKmerArray,totalLength-rightSideLength);
                    combinedKmerArray= leftShiftOutFromArray(combinedKmerArray, totalLength-rightSideLength);
                    long[] newSubKmer = leftShiftArray(combinedKmerArray,totalLength-rightSideLength-maxKmerSize+1);
                    combinedKmerArray = leftShiftOutFromArray(combinedKmerArray,totalLength-rightSideLength-maxKmerSize+1);
                    combinedKmerArray= combineTwoLongBlocks(rightResidue,combinedKmerArray);

                    long attribute = onlyChangeReflexivMarker(subKmer.getLong(1), 1);

                    newSubKmer=reverseBinaryBlocks(newSubKmer); // reverse right subKmer

                    return RowFactory.create(
                            newSubKmer,attribute,combinedKmerArray);

                }else{
                    return subKmer;
                }
            }else{
                if (getLeftMarker(subKmer.getLong(1))<-1 && getRightMarker(subKmer.getLong(1))<-1){
                    long[] combinedKmerArray;
                    if (getReflexivMarker(subKmer.getLong(1))==1){
                        combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                    }else{ // reflexed
                        combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                    }
                    /**
                     *         A----------  This K-mer has been removed in kmer preparation step
                     *    ----XA--------- A is the mutation X is one Kmer over the muation.
                     */
                    // -----
                    int rightSideLength = -getRightMarker(subKmer.getLong(1))-1 +2;   // ----XA--------- A is the mutation X is one Kmer over the muation.
                    long[] newReflexivKmer = leftShiftArray(combinedKmerArray,totalLength-rightSideLength);
                    long[] newSubKmer = leftShiftOutFromArray(combinedKmerArray,totalLength-rightSideLength);

                    long newReflexivMarker = onlyChangeReflexivMarker(subKmer.getLong(1), 1);

                    newSubKmer=reverseBinaryBlocks(newSubKmer); // reverse right subKmer

                    return RowFactory.create(
                            newSubKmer,newReflexivMarker,newReflexivKmer);
                }else{
                    return subKmer;
                }
            }

        }

        private Row rightPreparationArray(long[] subKmerArray, long attr, long[] extensionArray) throws Exception {
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getRightMarker(attr)>0){
                    long[] combinedKmerArray;
                    if (getReflexivMarker(attr)==1){
                        combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                    }else{ // reflexed
                        combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                    }

                    int rightSideLength = maxKmerSize + 3 - getRightMarker(attr) +1 ; // branching point
                    long[] rightResidue = leftShiftArray(combinedKmerArray,totalLength-rightSideLength);
                    combinedKmerArray= leftShiftOutFromArray(combinedKmerArray, totalLength-rightSideLength);
                    long[] newSubKmer = leftShiftArray(combinedKmerArray,totalLength-rightSideLength-maxKmerSize+1);
                    combinedKmerArray = leftShiftOutFromArray(combinedKmerArray,totalLength-rightSideLength-maxKmerSize+1);
                    combinedKmerArray= combineTwoLongBlocks(rightResidue,combinedKmerArray);

                    long attribute = onlyChangeReflexivMarker(attr, 1);
                   // System.out.println("before reverse: " + BinaryBlocksToString(newSubKmer));
                    newSubKmer=reverseBinaryBlocks(newSubKmer); // reverse right subKmer
                   // System.out.println("after reverse: " + BinaryBlocksToString(newSubKmer));
                    return RowFactory.create(
                            newSubKmer,attribute,combinedKmerArray);

                }else{
                    return RowFactory.create(
                            subKmerArray,attr,extensionArray);
                }
            }else{
                if (getLeftMarker(attr)<-1 && getRightMarker(attr)<-1){
                    long[] combinedKmerArray;
                    if (getReflexivMarker(attr)==1){
                        combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                    }else{ // reflexed
                        combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                    }
                    /**
                     *         A----------  This K-mer has been removed in kmer preparation step
                     *    ----XA--------- A is the mutation X is one Kmer over the muation.
                     */
                    // -----
                    int rightSideLength = -getRightMarker(attr)-1 +2;   // ----XA--------- A is the mutation X is one Kmer over the muation.
                    long[] newReflexivKmer = leftShiftArray(combinedKmerArray,totalLength-rightSideLength);
                    long[] newSubKmer = leftShiftOutFromArray(combinedKmerArray,totalLength-rightSideLength);

                    long newReflexivMarker = onlyChangeReflexivMarker(attr, 1);

                    newSubKmer=reverseBinaryBlocks(newSubKmer);
                    return RowFactory.create(
                            newSubKmer,newReflexivMarker,newReflexivKmer);
                }else{
                    return RowFactory.create(
                            subKmerArray,attr,extensionArray);
                }
            }
        }

        private Row leftLongBranchCorrectionAndRightPreparation(Row subKmer, boolean change) throws Exception{
            long[] subKmerArray = seq2array(subKmer.getSeq(0));
            long[] extensionArray =seq2array(subKmer.getSeq(2));
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getLeftMarker(subKmer.getLong(1))>0){
                    int leftSideLength = maxKmerSize + 3 - getLeftMarker(subKmer.getLong(1)) + 1;
                    long[] leftResidue = leftShiftOutFromArray(extensionArray, leftSideLength);  // 1111133333333333333 -> 11111
                    long[] newExtension = leftShiftArray(extensionArray, leftSideLength);          // 1111133333333333333 -> 3333333333333

                    long[] newSubKmer = combineTwoLongBlocks(leftResidue, subKmerArray);              // 11111 + 2222222 - 111112222222
                    newSubKmer = combineTwoLongBlocks(newSubKmer, newExtension);                        // 111112222222 + 3333333333333
                    newExtension = leftShiftArray(newSubKmer, maxKmerSize - 1);                           // 1111122 222223333333333333
                    newSubKmer = leftShiftOutFromArray(newSubKmer, maxKmerSize - 1);                      // 1111122

                    long attribute;
                    if (change){
                        attribute = buildingAlongFromThreeInt(1, -1, getRightMarker(subKmer.getLong(1)));
                    }else {
                        attribute = onlyChangeReflexivMarker(subKmer.getLong(1), 1);
                    }

                    return rightPreparationArray(newSubKmer, attribute, newExtension);
                }else{
                    return rightPreparation(subKmer);
                }
            }else{
                return rightPreparation(subKmer);
            }
        }

        private Row leftLongBranchCorrectionArray(long[] subKmerArray, long attr, long[] extensionArray, boolean change) throws Exception {
            int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
            int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
            int totalLength = subKmerLength+extensionLength;

            if (totalLength>=2*maxKmerSize){
                if (getLeftMarker(attr)>0){
                    int leftSideLength = maxKmerSize + 3 - getLeftMarker(attr) + 1;
                    long[] leftResidue = leftShiftOutFromArray(extensionArray, leftSideLength);  // 1111133333333333333 -> 11111
                    long[] newExtension = leftShiftArray(extensionArray, leftSideLength);          // 1111133333333333333 -> 3333333333333

                    long[] newSubKmer = combineTwoLongBlocks(leftResidue, subKmerArray);              // 11111 + 2222222 - 111112222222
                    newSubKmer = combineTwoLongBlocks(newSubKmer, newExtension);                        // 111112222222 + 3333333333333
                    newExtension = leftShiftArray(newSubKmer, maxKmerSize - 1);                           // 1111122 222223333333333333
                    newSubKmer = leftShiftOutFromArray(newSubKmer, maxKmerSize - 1);                      // 1111122

                    if (change){
                        attr=buildingAlongFromThreeInt(1, -1, getRightMarker(attr));
                    }else{
                        attr=onlyChangeReflexivMarker(attr, 1);
                    }
                    return RowFactory.create(newSubKmer, attr, newExtension);
                }else{
                    return RowFactory.create(subKmerArray, attr, extensionArray);
                }
            }else{
                return RowFactory.create(subKmerArray, attr, extensionArray);
            }
        }

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while(s.hasNext()) {
                Row subKmer = s.next();

                if (lastSubKmer==null){
                    lastSubKmer=subKmer;
                    continue;
                }

                long[] subKmerArray = seq2array(subKmer.getSeq(0));
                long[] extensionArray = seq2array(subKmer.getSeq(2));
                int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
                int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
                int totalLength = subKmerLength + extensionLength;

                if (totalLength >= 2*maxKmerSize){
                    if (getLeftMarker(subKmer.getLong(1))>0) {
                        long[] lastSubKmerArray = seq2array(lastSubKmer.getSeq(0));
                        long[] lastExtensionArray = seq2array(lastSubKmer.getSeq(2));
                        int lastSubKmerLength = currentKmerSizeFromBinaryBlockArray(lastSubKmerArray);
                        int lastExtensionLength = currentKmerSizeFromBinaryBlockArray(lastExtensionArray);
                        int lastTotalLength = lastSubKmerLength + lastExtensionLength;

                        if (lastTotalLength < 2 * maxKmerSize) {
                            if (getLeftMarker(lastSubKmer.getLong(1)) < -1 && getRightMarker(lastSubKmer.getLong(1)) < -1) {
                                if (dynamicSubKmerComparator(subKmer.getSeq(0), lastSubKmer.getSeq(0)) == true) {
                                    Row newSubKmer=leftLongBranchCorrectionArray(subKmerArray,subKmer.getLong(1), extensionArray, true);

                                 //   System.out.println("left 1 before short: " + BinaryBlocksToString(lastSubKmerArray) + " extension: " + BinaryBlocksToString(lastExtensionArray) + " leftMarker: " + getLeftMarker(lastSubKmer.getLong(1)));
                                //    System.out.println("left 1 before: " + BinaryBlocksToString(subKmerArray) + " extension: " + BinaryBlocksToString(extensionArray)
                                //    + " leftMarker: " + getLeftMarker(subKmer.getLong(1)) + " rightMarker: " + getRightMarker(subKmer.getLong(1)) + " reflexivMarker: " + getReflexivMarker(subKmer.getLong(1)) + " after: " + BinaryBlocksToString((long[])newSubKmer.get(0)) + " extension: " + BinaryBlocksToString((long[])newSubKmer.get(2))
                                //    + " newLeftMarker: " + getLeftMarker(newSubKmer.getLong(1)) + " newRightMarker: " + getRightMarker(newSubKmer.getLong(1)) + " newReflexivMarker: " + getReflexivMarker(newSubKmer.getLong(1)));

                                    kmerList.add(rightPreparation(lastSubKmer));
                                    kmerList.add(rightPreparationArray((long[])newSubKmer.get(0), newSubKmer.getLong(1), (long[])newSubKmer.get(2)));
                                    lastSubKmer = null;

                                  //  Row tempSubKmer1=kmerList.get(kmerList.size()-2);
                                    Row tempSubKmer2=kmerList.get(kmerList.size()-1);
                                  //  System.out.println("left 1 preparation short: " + BinaryBlocksToString((long[])tempSubKmer1.get(0)) + " extension: " + BinaryBlocksToString((long[])tempSubKmer1.get(2)) + " leftMarker: " + getLeftMarker(tempSubKmer1.getLong(1)));
                                 //   System.out.println("left 1 preparation long: " + BinaryBlocksToString((long[])tempSubKmer2.get(0)) + " extension: " + BinaryBlocksToString((long[])tempSubKmer2.get(2)) + " leftMarker: " + getLeftMarker(tempSubKmer2.getLong(1)));
                                } else {
                                    kmerList.add(rightPreparation(lastSubKmer));
                                    lastSubKmer = subKmer;
                                }
                            } else {
                                kmerList.add(rightPreparation(lastSubKmer));
                                lastSubKmer = subKmer;
                            }
                        } else {
                            Row newSubKmer=leftLongBranchCorrectionAndRightPreparation(lastSubKmer, false);
                            kmerList.add(newSubKmer);
                            lastSubKmer = subKmer;
                        }
                    }else{
                        Row newSubKmer=leftLongBranchCorrectionAndRightPreparation(lastSubKmer, false);
                        kmerList.add(newSubKmer);
                        lastSubKmer = subKmer;
                    }
                }else{
                    if (getLeftMarker(subKmer.getLong(1)) < -1 && getRightMarker(subKmer.getLong(1)) < -1) {
                        if (getLeftMarker(lastSubKmer.getLong(1)) > 0) {

                            long[] lastSubKmerArray = seq2array(lastSubKmer.getSeq(0));
                            long[] lastExtensionArray = seq2array(lastSubKmer.getSeq(2));
                            int lastSubKmerLength = currentKmerSizeFromBinaryBlockArray(lastSubKmerArray);
                            int lastExtensionLength = currentKmerSizeFromBinaryBlockArray(lastExtensionArray);
                            int lastTotalLength = lastSubKmerLength + lastExtensionLength;

                            if (lastTotalLength >=2*maxKmerSize){

                                if (dynamicSubKmerComparator(subKmer.getSeq(0), lastSubKmer.getSeq(0)) == true) {
                                    Row newLastSubKmer = leftLongBranchCorrectionArray(lastSubKmerArray, lastSubKmer.getLong(1), lastExtensionArray, true);
                             //       System.out.println("left 2 before: " + BinaryBlocksToString(lastSubKmerArray) + " extension: " + BinaryBlocksToString(lastExtensionArray)
                              //              + " leftMarker: " + getLeftMarker(lastSubKmer.getLong(1)) + " rightMarker: " + getRightMarker(lastSubKmer.getLong(1)) + " reflexivMarker: " + getReflexivMarker(lastSubKmer.getLong(1)) + " after: " + BinaryBlocksToString((long[])newLastSubKmer.get(0)) + " extension: " + BinaryBlocksToString((long[])newLastSubKmer.get(2))
                               //             + " newLeftMarker: " + getLeftMarker(newLastSubKmer.getLong(1)) + " newRightMarker: " + getRightMarker(newLastSubKmer.getLong(1)) + " newReflexivMarker: " + getReflexivMarker(newLastSubKmer.getLong(1)) );



                                    kmerList.add(rightPreparationArray((long[])newLastSubKmer.get(0), newLastSubKmer.getLong(1), (long[])newLastSubKmer.get(2)));
                                    kmerList.add(rightPreparation(subKmer));
                                    lastSubKmer=null;

                                    Row TempSubKmer=kmerList.get(kmerList.size()-2);
                        //            System.out.println("left 2 after Preparation: " + BinaryBlocksToString((long[])TempSubKmer.get(0)) + " extension: " + BinaryBlocksToString((long[])TempSubKmer.get(2)));
                                }else{
                                    Row newLastSubKmer = leftLongBranchCorrectionArray(lastSubKmerArray, lastSubKmer.getLong(1), lastExtensionArray, false);

                                    kmerList.add(rightPreparationArray((long[])newLastSubKmer.get(0), newLastSubKmer.getLong(1), (long[])newLastSubKmer.get(2)));// change long left marked kmer back to normal reflexiv kmer
                                    lastSubKmer=subKmer;
                                    Row TempSubKmer=kmerList.get(kmerList.size()-1);
                        //            System.out.println("left 2 after Preparation: " + BinaryBlocksToString((long[])TempSubKmer.get(0)) + " extension: " + BinaryBlocksToString((long[])TempSubKmer.get(2)));
                                }
                            }else{
                                kmerList.add(rightPreparation(lastSubKmer));
                                lastSubKmer=subKmer;
                            }
                        } else {
                            kmerList.add(rightPreparation(lastSubKmer));
                            lastSubKmer=subKmer;
                        }
                    } else {
                      //  kmerList.add(lastSubKmer); // does not need to be prepared
                        kmerList.add(leftLongBranchCorrectionAndRightPreparation(lastSubKmer, false));
                        lastSubKmer=subKmer;
                    }
                }
            }

            if (lastSubKmer!=null){
                Row newLastSubKmer=leftLongBranchCorrectionAndRightPreparation(lastSubKmer, false);
                kmerList.add(newLastSubKmer);
            }

            return kmerList.iterator();
        }

        private long[] reverseBinaryBlocks(long[] blocks){
            int length = currentKmerSizeFromBinaryBlockArray(blocks);
            int blockNumber= blocks.length;
            long[] newBlocks= new long[blockNumber];
            int reverseIndex;
            int reverseBlockIndex;
            int relativeReverseIndex;

            int forwardBlockIndex;

            long twoBits;
            for (int i=0; i<length;i++){
                reverseIndex=length-i-1;
                reverseBlockIndex=reverseIndex/31;
                relativeReverseIndex=reverseIndex%31;

                forwardBlockIndex=i/31;

                twoBits=blocks[reverseBlockIndex] >>>2*(31-relativeReverseIndex);
                twoBits&=3L;

                newBlocks[forwardBlockIndex]|=twoBits;
                newBlocks[forwardBlockIndex] <<=2;
            }
            int lastBlockShift=31-(length-1)%31-1;
            newBlocks[newBlocks.length-1] <<=2*lastBlockShift;
            newBlocks[newBlocks.length - 1] |= (1L << 2 * (lastBlockShift));

            return newBlocks;
        }

        private boolean dynamicSubKmerComparator(Seq a, Seq b) throws Exception {
            long[] arrayA = seq2array(a);
            long[] arrayB = seq2array(b);

            int aLength= currentKmerSizeFromBinaryBlockArray(arrayA);
            int bLength= currentKmerSizeFromBinaryBlockArray(arrayB);

           // String arrayAString = BinaryBlocksToString(arrayA);
           // String arrayBString = BinaryBlocksToString(arrayB);

            //     System.out.println("different comparator: " + arrayAString + " B: " + arrayBString);

            if (aLength>=bLength){ // equal should not happen
                long[] shorterVersion = leftShiftOutFromArray(arrayA, bLength);
                if (Arrays.equals(shorterVersion, arrayB)){
                    return true;
                }else{
                    return false;
                }
            }else{
                long[] shorterVersion = leftShiftOutFromArray(arrayB, aLength);
                if (Arrays.equals(shorterVersion, arrayA)){
                    return true;
                }else{
                    return false;
                }
            }
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31; // xxxxxxxxxxx-- xxxxxxx-------
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

        //    String seq= BinaryBlocksToString(blocks);
            //           System.out.println("seq: " + seq + " shiftingLength: " + shiftingLength + " nucleotideLength: " + nucleotideLength + " residueLength: " + residueLength);

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            //   System.out.println("relativeShiftSize: " + relativeShiftSize + " j: " + j);
            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            if (shiftingLength<=0){ // return an empty array
                long[] a = new long[1];
                a[0]= (1L << 2*31); // 01xxxxxxxxxx
                return a;
            }

            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
              //  String rightBlocksString = BinaryBlocksToString(rightBlocks);
              //  String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                  //  if (i>=newBlocks.length){
                   //     System.out.println("leftLength: " + leftNucleotideLength + " right " + rightNucleotideLength + " combinedBlock: " + combinedBlockSize + "newBlocksLength: " + newBlocks.length);
                   // }
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
              //      String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

             //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //               System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            if (suffix0s>=63){
                suffix0s=62;
            }
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

    }

    class DSShortBranchRemovalPreparationLeft implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList = new ArrayList<Row>();
        int maxKmerSize = param.kmerListInt[param.kmerListInt.length-1];

        public Iterator<Row> call(Iterator<Row> s) throws Exception {
            while (s.hasNext()){
                Row subKmer=s.next();

                long[] subKmerArray = seq2array(subKmer.getSeq(0));
                long[] extensionArray =seq2array(subKmer.getSeq(2));
                int subKmerLength = currentKmerSizeFromBinaryBlockArray(subKmerArray);
                int extensionLength = currentKmerSizeFromBinaryBlockArray(extensionArray);
                int totalLength = subKmerLength+extensionLength;

                if (totalLength>=2*maxKmerSize){
                    if (getLeftMarker(subKmer.getLong(1))>0){
                        long[] combinedKmerArray;
                        if (getReflexivMarker(subKmer.getLong(1))==1){
                            combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                        }else{ // reflexed
                            combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                        }


                        int leftSideLength = maxKmerSize + 3 - getLeftMarker(subKmer.getLong(1)) +1 ; // branching point
                        long[] leftResidue = leftShiftOutFromArray(combinedKmerArray,leftSideLength);
                        combinedKmerArray= leftShiftArray(combinedKmerArray, leftSideLength);
                        long[] newSubKmer = leftShiftOutFromArray(combinedKmerArray,maxKmerSize-1);
                        combinedKmerArray = leftShiftArray(combinedKmerArray,maxKmerSize-1);
                        combinedKmerArray= combineTwoLongBlocks(leftResidue,combinedKmerArray);

                        long attribute = onlyChangeReflexivMarker(subKmer.getLong(1), 2);

                        kmerList.add(RowFactory.create(
                                newSubKmer,attribute,combinedKmerArray)
                        );

                    }else{
                        kmerList.add(subKmer);
                    }
                }else{
                    if (getLeftMarker(subKmer.getLong(1))<-1 && getRightMarker(subKmer.getLong(1))<-1){
                        long[] combinedKmerArray;
                        if (getReflexivMarker(subKmer.getLong(1))==1){
                            combinedKmerArray=combineTwoLongBlocks(subKmerArray,extensionArray);
                        }else{ // reflexed
                            combinedKmerArray=combineTwoLongBlocks(extensionArray,subKmerArray);
                        }
                        /**
                         *         A----------  This K-mer has been removed in kmer preparation step
                         *    ----XA--------- A is the mutation X is one Kmer over the muation.
                         */
                                                                                        // -----
                        int leftSideLength = -getLeftMarker(subKmer.getLong(1))-1 +2;   // ----XA--------- A is the mutation X is one Kmer over the muation.
                        long[] newReflexivKmer = leftShiftOutFromArray(combinedKmerArray,leftSideLength);
                        long[] newSubKmer = leftShiftArray(combinedKmerArray,leftSideLength);

                        long newReflexivMarker = onlyChangeReflexivMarker(subKmer.getLong(1), 2);
                        kmerList.add(RowFactory.create(
                                newSubKmer,newReflexivMarker,newReflexivKmer)
                        );
                    }else{
                        kmerList.add(subKmer);
                    }
                }

            }
            return kmerList.iterator();
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }


        private long[] seq2array(Seq a){
            long[] array =new long[a.length()];
            for (int i = 0; i < a.length(); i++) {
                array[i] = (Long) a.apply(i);
            }
            return array;
        }

        private long[] leftShiftArray(long[] blocks, int shiftingLength) throws Exception {
            int startingBlockIndex = (shiftingLength)/31; // xxxxxxxxxxx-- xxxxxxx-------
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            int residueLength = Long.SIZE / 2 - (Long.numberOfTrailingZeros(blocks[blocks.length-1])/2+1); // last block length

          //  String seq= BinaryBlocksToString(blocks);
            //           System.out.println("seq: " + seq + " shiftingLength: " + shiftingLength + " nucleotideLength: " + nucleotideLength + " residueLength: " + residueLength);

            int remainLength=nucleotideLength-shiftingLength-1;
            if (remainLength <0){
                remainLength=0;
            }
            long[] newBlock = new long[remainLength/31+1];
            int relativeShiftSize = shiftingLength % 31;

            if (shiftingLength >= nucleotideLength){
                // apparantly, it is possible. meaning the block has nothing left
                // throw new Exception("shifting length longer than the kmer length");
                newBlock[0]|=(1L<<2*31); //add c marker at the end
                return newBlock;
            }

            // if (relativeShiftSize ==0) then only shifting blocks

            int j=0; // new index for shifted blocks
            //           long oldShiftOut=0L; // if only one block, then 0 bits
//            if (blocks.length-(startingBlockIndex+1) >=1) { // more than one block, newBlock.length = blocks.length-startingBlockIndex
//                oldShiftOut = blocks[startingBlockIndex + 1] >>> 2 * (32 - relativeShiftSize);
            //           }
            for (int i=startingBlockIndex; i<blocks.length-1; i++){ // without the last block
                long shiftOut = blocks[i+1] >>> 2*(31-relativeShiftSize); // ooooxxxxxxx -> -------oooo  o=shift out x=needs to be left shifted
                newBlock[j]= blocks[i] << 2*relativeShiftSize; // 00000xxxxx -> xxxxx-----
                newBlock[j] |= shiftOut;
                newBlock[j] &= (~0L<<2); // remove the last two bits, in case of overlength  xxxxxxxxxxx - > xxxxxxxxxxx-  C marker will be added later if necessary

                j++;
            }

            //   System.out.println("relativeShiftSize: " + relativeShiftSize + " j: " + j);
            if (residueLength > relativeShiftSize){ // still some nucleotide left in the last block
                newBlock[j]= blocks[blocks.length-1] << 2*relativeShiftSize;
            }else if (residueLength == relativeShiftSize){ // nothing left in the last block, but the new last block needs a C marker in the end
                newBlock[j-1] |= 1L; // j-1 == newBlock.length-1
            } // else the last block has been completely shift into the new last block, including the C marker

            return newBlock;

        }

        private long[] leftShiftOutFromArray(long[] blocks, int shiftingLength) throws Exception{
            if (shiftingLength<=0){ // return an empty array
                long[] a = new long[1];
                a[0]= (1L << 2*31); // 01xxxxxxxxxx
                return a;
            }

            int relativeShiftSize = shiftingLength % 31;
            int endingBlockIndex = (shiftingLength-1)/31;
            int nucleotideLength = currentKmerSizeFromBinaryBlockArray(blocks);
            long[] shiftOutBlocks = new long[endingBlockIndex+1];

            if (shiftingLength > nucleotideLength){
                // throw new Exception("shifting length longer than the kmer length");
                return blocks;
            }

            for (int i=0; i<endingBlockIndex; i++){
                shiftOutBlocks[i]=blocks[i];
            }

            if (relativeShiftSize > 0) {
                shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex] & (~0L << 2 * (32 - relativeShiftSize));  //   1111111100000000000
                shiftOutBlocks[endingBlockIndex] |= (1L << (2 * (32 - relativeShiftSize - 1)));
            }else{ // relativeShiftSize == 0;
                if (endingBlockIndex+1 == blocks.length) { // a block with C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                }else{ // endingBlockIndex < blocks.length -1     means a block without C marker
                    shiftOutBlocks[endingBlockIndex] = blocks[endingBlockIndex];
                    shiftOutBlocks[endingBlockIndex]|=1L;  // adding C marker in the end xxxxxxxxxC
                }

            }

            return shiftOutBlocks;
        }

        private long[] combineTwoLongBlocks(long[] leftBlocks, long[] rightBlocks) throws Exception {
            int leftNucleotideLength = currentKmerSizeFromBinaryBlockArray(leftBlocks);
            int leftRelativeNTLength = (leftNucleotideLength-1) % 31+1;
            int leftVacancy = 31-leftRelativeNTLength;
            int rightNucleotideLength = currentKmerSizeFromBinaryBlockArray(rightBlocks);
            int combinedBlockSize = (leftNucleotideLength+rightNucleotideLength-1)/31+1;
            long[] newBlocks= new long[combinedBlockSize];

            if (rightNucleotideLength==0){
                return leftBlocks;
            }

            if (leftNucleotideLength==0){
                return rightBlocks;
            }

            if (leftVacancy ==0){ // left last block is a perfect block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove the last block's C marker

                for (int j=leftBlocks.length;j<combinedBlockSize;j++){
                    newBlocks[j]=rightBlocks[j-leftBlocks.length];
                }
            }else{
              //  String rightBlocksString = BinaryBlocksToString(rightBlocks);
             //   String leftBlocksString = BinaryBlocksToString(leftBlocks);

                long[] shiftOutBlocks = leftShiftOutFromArray(rightBlocks, leftVacancy); // right shift out for the left. here we only expect one block, because leftVacancy is relative to one block
                for (int i =0; i<leftBlocks.length; i++){
                    newBlocks[i]=leftBlocks[i];
                }

                newBlocks[leftBlocks.length-1] &= (~0L<<2*(leftVacancy+1)); // leftVacancy = 32-leftRelativeNTLength-1. This is to remove the C marker
                newBlocks[leftBlocks.length-1] |= (shiftOutBlocks[0]>>> 2*(leftRelativeNTLength));
                if (leftBlocks.length<combinedBlockSize) { // this is not the end block, the last 2 bits (C marker) of shift out needs to be removed  ----------C
                    newBlocks[leftBlocks.length-1] &= (~0L<<2); // remove shift out blocks C marker. apparently, if there is a C marker, this is the last block anyway
                }

                long[] rightBlocksLeftShifted = leftShiftArray(rightBlocks, leftVacancy);

                int k=0; // rightBlocksLeftShifted index
                for (int j=leftBlocks.length;j<combinedBlockSize;j++){ // including the last blocks.
                    newBlocks[j]=rightBlocksLeftShifted[k];
                    k++;
                    long[] rightBlocksLeftShiftedArray= new long[1];
                    rightBlocksLeftShiftedArray[0]=rightBlocksLeftShifted[k-1];
             //       String rightShift= BinaryBlocksToString(rightBlocksLeftShiftedArray);
                    //  System.out.println("rightShift: " + rightShift);
                }

             //   String mergedKmer= BinaryBlocksToString(newBlocks);

                //               System.out.println(" left Blocks:" + leftBlocksString + " Right blocks: " + rightBlocksString + " rightLength: " + rightNucleotideLength + " leftNucleotideLength: " + leftNucleotideLength + " leftRelativeNTLength: " + leftRelativeNTLength + " leftVacancy: " + leftVacancy + " rightNucleotideLength: " + rightNucleotideLength + " combinedBlockSize: " + combinedBlockSize + " newBlock: " + mergedKmer);
            }

            return newBlocks;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            if (suffix0s >=63){
                suffix0s=62;
            }
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private int getReflexivMarker(long attribute){
            int reflexivMarker = (int) (attribute >>> 2*(32-1)); // 01-------- -> ---------01 reflexiv marker
            return reflexivMarker;
        }

        private int getLeftMarker(long attribute){
            int leftMarker = (int) (attribute >>> 2*(16)); // 01--xxxx-----xxxx -> 01--xxxx shift out right marker
            int leftMarkerBinaryBits= ~(3 << 30) ; // ---------11 -> 11---------- -> 0011111111111
            leftMarker &= leftMarkerBinaryBits; // remove reflexivMarker

            if (leftMarker>30000){
                leftMarker=30000-leftMarker;
            }

            return leftMarker;
        }

        private int getRightMarker(long attribute){
            int rightMarker = (int) attribute;

            if (rightMarker>30000){
                rightMarker=30000-rightMarker;
            }

            return rightMarker;
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }
    }

    /**
     * interface class for RDD implementation, used in step 5
     */

    /**
     * interface class for RDD implementation, used in step 4
     */


    class DSKmerReverseComplement implements MapPartitionsFunction<Row, Row>, Serializable {
        /* a capsule for all Kmers and reverseComplementKmers */
        List<Row> kmerList = new ArrayList<Row>();
        long[] reverseComplement;
        long[] forwardKmer;
        Row kmerTuple;
        Long lastTwoBits;
        Seq kmerBinarySeq;

        int currentKmerBlockSize;
        int currentKmerSize;
        int currentKmerResidue;


        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {
                kmerTuple = s.next();
                kmerBinarySeq = kmerTuple.getSeq(0);
                //reverseComplement=0L;

                currentKmerBlockSize = kmerBinarySeq.length();
                currentKmerSize = currentKmerSizeFromBinaryBlock(kmerBinarySeq);
                currentKmerResidue = currentKmerResidueFromBlock(kmerBinarySeq);

                forwardKmer = new long[currentKmerBlockSize];
                reverseComplement = new long[currentKmerBlockSize];

                for (int i = 0; i < currentKmerSize; i++) {
                    int RCindex = currentKmerSize - i - 1; //  ------------- ------------- ---------**-- RC index goes reverse
                    //  ------------- ------------- -------**----  <--
                   // reverseComplement[i / 31] <<= 2;

                    if (RCindex >= currentKmerSize - currentKmerResidue) {
                        lastTwoBits = (Long) kmerBinarySeq.apply(RCindex / 31) >>> 2 * (32-(RCindex % 31)-1);    //  ------------- ------------- ------|----**
                        lastTwoBits &= 3L;
                        lastTwoBits ^= 3L;
                    } else {
                        lastTwoBits = (Long) kmerBinarySeq.apply(RCindex / 31) >>> 2 * (32 - (RCindex % 31) - 1);
                        lastTwoBits &= 3L;
                        lastTwoBits ^= 3L;
                    }
                    reverseComplement[i / 31] <<=2;
                    reverseComplement[i / 31] |= lastTwoBits;
                }
                reverseComplement[(currentKmerSize-1)/31]|=(1L<<2*(32-currentKmerResidue-1)); // adding ending marker C


                for (int i = 0; i < param.kmerBinarySlotsAssemble; i++) {
                    forwardKmer[i] = (Long) kmerTuple.getSeq(0).apply(i);
                }

                kmerList.add(RowFactory.create(forwardKmer, kmerTuple.getInt(1)));
                kmerList.add(RowFactory.create(reverseComplement, kmerTuple.getInt(1)));

            }

            return kmerList.iterator();
        }

        private int currentKmerResidueFromBlock(Seq binaryBlocks){
            final int suffix0s = Long.numberOfTrailingZeros((Long)binaryBlocks.apply(binaryBlocks.length()-1));
            return Long.SIZE/2 - suffix0s/2 -1; // minus one for ending marker
        }

        private int currentKmerSizeFromBinaryBlock(Seq binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length();
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros((Long) binaryBlocks.apply(blockSize - 1)); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2 -1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }
    }

    class DSKmerReverseComplementLong implements MapPartitionsFunction<Row, Row>, Serializable {
        /* a capsule for all Kmers and reverseComplementKmers */
        List<Row> kmerList = new ArrayList<Row>();
        Long reverseComplement;
        Row kmerTuple;
        Long lastTwoBits;
        Long kmerBinary;


        public Iterator<Row> call(Iterator<Row> s) {


            while (s.hasNext()) {
                kmerTuple = s.next();
                kmerBinary = kmerTuple.getLong(0);
                reverseComplement = 0L;
                for (int i = 0; i < param.kmerSize; i++) {
                    reverseComplement <<= 2;

                    lastTwoBits = kmerBinary & 3L ^ 3L;
                    kmerBinary >>>= 2;
                    reverseComplement |= lastTwoBits;
                }

                kmerList.add(RowFactory.create(kmerTuple.getLong(0), (int) kmerTuple.getLong(1)));
                kmerList.add(RowFactory.create(reverseComplement, (int) kmerTuple.getLong(1)));
            }

            return kmerList.iterator();
        }
    }

    class DynamicKmerBinarizerFromReducedToSubKmer implements MapPartitionsFunction<Row, Row>, Serializable{
        List<Row> kmerList = new ArrayList<Row>();
        Row units;
        String kmer;
        int currentKmerSize;
        int currentKmerBlockSize;
        int currentSubKmerSize;
        int currentSubKmerBlockSize;
        long attribute;
        char nucleotide;
        long nucleotideInt;
        //     Long suffixBinary;
        //     Long[] suffixBinaryArray;

        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {
                units = s.next();

                kmer = units.getString(0);

                if (kmer.startsWith("(")) {
                    kmer = kmer.substring(1);
                }

                currentKmerSize= kmer.length();
                currentSubKmerSize = currentKmerSize-1;
                currentKmerBlockSize = (currentKmerSize-1)/31+1; // each 31 mer is a block
                currentSubKmerBlockSize = (currentSubKmerSize-1)/31+1;

                if (!kmerSizeCheck(kmer, param.kmerListHash)){continue;} // the kmer length does not fit into any of the kmers in the list.

                if (units.getString(1).endsWith(")")) {
                    String[] attributeStringArray = StringUtils.chop(units.getString(1)).split("\\|");
                    attribute = buildingAlongFromThreeInt(
                            Integer.parseInt(attributeStringArray[0]),Integer.parseInt(attributeStringArray[1]),Integer.parseInt(attributeStringArray[2])
                    );
                   // attribute = Long.parseLong(StringUtils.chop(units.getString(1)));
                } else {
                    String[] attributeStringArray = units.getString(1).split("\\|");
                    attribute = buildingAlongFromThreeInt(
                            Integer.parseInt(attributeStringArray[0]),Integer.parseInt(attributeStringArray[1]),Integer.parseInt(attributeStringArray[2])
                    );
                    // attribute = Long.parseLong(units.getString(1));
                }

                long[] nucleotideBinarySlot = new long[currentSubKmerBlockSize];
                //       Long nucleotideBinary = 0L;

                for (int i = 0; i < currentSubKmerSize; i++) {
                    nucleotide = kmer.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);
                    // forward kmer in bits
                    nucleotideInt <<= 2*(32-1-(i%31)); // shift to the left   [ATCGGATCC-,ATCGGATCC-]
//                    nucleotideBinarySlot[i / 31] <<= 2*((32-i)%32);
                    nucleotideBinarySlot[i / 31] |= nucleotideInt;

                    //   nucleotideBinary <<= 2;
                    //   nucleotideBinary |= nucleotideInt;
                }

                char lastNt= kmer.charAt(currentSubKmerSize); // currentKmerBlockSize -1
                if (lastNt >= 256) lastNt = 255;
                long lastNtLong = nucleotideValue(lastNt);
                lastNtLong<<=2*31; // ------------xx -> xx--------------
                lastNtLong|= (1L<<2*30); // add c marker

                // marking the end of the kmer
                long kmerEndMark = 1L;
                kmerEndMark <<= 2*(32-1-((currentSubKmerSize-1)%31+1));
                nucleotideBinarySlot[currentSubKmerBlockSize-1] |= kmerEndMark; // param.kmerListHash.get(currentKmerSize)] == currentKmerBlockSize

            //    String seq = BinaryBlocksToString(nucleotideBinarySlot);
                long[] lastNtLongArray = new long[1];
                lastNtLongArray[0]= lastNtLong;
             //   String suffix = BinaryBlocksToString(lastNtLongArray);
                long a = (attribute>>>2*63);
             //   System.out.println("Fresh binarized: " + seq + " marker: " + a + " extra: " + suffix);
                // return

                attribute= onlyChangeReflexivMarker(attribute,1);
                kmerList.add(
                        RowFactory.create(nucleotideBinarySlot, attribute, lastNtLong)
                );
            }

            return kmerList.iterator();
        }

        private long buildingAlongFromThreeInt(int ReflexivMarker, int leftCover, int rightCover){
            long info = (long) ReflexivMarker <<2*(32-1);  //move to the left most

            /**
             * shorten the int and change negative to positive to avoid two's complementary
             */
            if (leftCover>=30000){
                leftCover=30000;
            }else if (leftCover<=-30000){
                leftCover=30000-(-30000);
            }else if (leftCover<0){
                leftCover=30000-leftCover;
            }

            if (rightCover>=30000){
                rightCover=30000;
            }else if (rightCover<=-30000){
                rightCover=30000-(-30000);
            }else if (rightCover<0){
                rightCover=30000-rightCover;
            }

            info |= ((long) leftCover << 32) ; // move one integer (32 bits) to the left
            info |= ((long) rightCover); //  01--LeftCover---RightCover

            return info;
        }

        private long onlyChangeReflexivMarker(long oldMarker, int reflexivMarker){
            Long maxSubKmerBinary = ~((~0L) << 2 * 31);
            long newMarker = oldMarker & maxSubKmerBinary;
            newMarker |= ((long) reflexivMarker) << 2*(32-1);
            return newMarker;
        }

        private boolean kmerSizeCheck(String kmer, HashMap<Integer, Integer> kmerList){
            if (kmerList.containsKey(kmer.length())) {
                return true;
            }else {
                return false;
            }
        }

        private long nucleotideValue(char a) {
            long value;
            if (a == 'A') {
                value = 0L;
            } else if (a == 'C') {
                value = 1L;
            } else if (a == 'G') {
                value = 2L;
            } else { // T
                value = 3L;
            }
            return value;
        }

        private String BinaryBlocksToString (long[] binaryBlocks){
            String KmerString="";
            int KmerLength = currentKmerSizeFromBinaryBlockArray(binaryBlocks);

            for (int i=0; i< KmerLength; i++){
                Long currentNucleotideBinary = binaryBlocks[i/31] >>> 2 * (32 - (i%31+1));
                currentNucleotideBinary &= 3L;
                char currentNucleotide = BinaryToNucleotide(currentNucleotideBinary);
                KmerString += currentNucleotide;
            }

            return KmerString;
        }
        private int currentKmerSizeFromBinaryBlockArray(long[] binaryBlocks){
            int kmerSize;
            int blockSize = binaryBlocks.length;
            kmerSize= (blockSize-1) *31;
            final int suffix0s = Long.numberOfTrailingZeros(binaryBlocks[blockSize - 1]); // ATCG...01---
            int lastMers = Long.SIZE/2-suffix0s/2-1;

            kmerSize+=lastMers;
            return kmerSize;

        }

        private char BinaryToNucleotide(Long twoBits) {
            char nucleotide;
            if (twoBits == 0L) {
                nucleotide = 'A';
            } else if (twoBits == 1L) {
                nucleotide = 'C';
            } else if (twoBits == 2L) {
                nucleotide = 'G';
            } else {
                nucleotide = 'T';
            }
            return nucleotide;
        }

    }

    class DynamicKmerBinarizer implements MapPartitionsFunction<Row, Row>, Serializable {

        List<Row> kmerList = new ArrayList<Row>();
        Row units;
        String kmer;
        int currentKmerSize;
        int currentKmerBlockSize;
        int cover;
        char nucleotide;
        long nucleotideInt;
        //     Long suffixBinary;
        //     Long[] suffixBinaryArray;

        public Iterator<Row> call(Iterator<Row> s) {

            while (s.hasNext()) {

                units = s.next();

                kmer = units.getString(0);

                if (kmer.startsWith("(")) {
                    kmer = kmer.substring(1);
                }

                currentKmerSize= kmer.length();
                currentKmerBlockSize = (currentKmerSize-1)/31+1; // each 31 mer is a block

                if (!kmerSizeCheck(kmer, param.kmerListHash)){continue;} // the kmer length does not fit into any of the kmers in the list.

                if (units.getString(1).endsWith(")")) {
                    if (units.getString(1).length() >= 11) {
                        cover = 1000000000;
                    } else {
                        cover = Integer.parseInt(StringUtils.chop(units.getString(1)));
                    }
                } else {
                    if (units.getString(1).length() >= 10) {
                        cover = 1000000000;
                    } else {
                        cover = Integer.parseInt(units.getString(1));
                    }
                }

                long[] nucleotideBinarySlot = new long[currentKmerBlockSize];
                //       Long nucleotideBinary = 0L;

                for (int i = 0; i < currentKmerSize; i++) {
                    nucleotide = kmer.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);
                    // forward kmer in bits
                    nucleotideInt <<= 2*(32-1-(i%31)); // shift to the left   [ATCGGATCC-,ATCGGATCC-]
//                    nucleotideBinarySlot[i / 31] <<= 2*((32-i)%32);
                    nucleotideBinarySlot[i / 31] |= nucleotideInt;

                    //   nucleotideBinary <<= 2;
                    //   nucleotideBinary |= nucleotideInt;
                }

                // marking the end of the kmer
                long kmerEndMark = 1L;
                kmerEndMark <<= 2*(32-1-((currentKmerSize-1)%31+1));
                nucleotideBinarySlot[param.kmerListHash.get(currentKmerSize)] |= kmerEndMark; // param.kmerListHash.get(currentKmerSize)] == currentKmerBlockSize

                // return
                kmerList.add(
                        RowFactory.create(nucleotideBinarySlot, cover)
                );
            }

            return kmerList.iterator();
        }

        private boolean kmerSizeCheck(String kmer, HashMap<Integer, Integer> kmerList){
            if (kmerList.containsKey(kmer.length())) {
                return true;
            }else {
                return false;
            }
        }

        private long nucleotideValue(char a) {
            long value;
            if (a == 'A') {
                value = 0L;
            } else if (a == 'C') {
                value = 1L;
            } else if (a == 'G') {
                value = 2L;
            } else { // T
                value = 3L;
            }
            return value;
        }

    }

    class ReverseComplementKmerBinaryExtractionFromDataset64 implements MapPartitionsFunction<String, Row>, Serializable{
        long maxKmerBits= ~((~0L) << (2*param.kmerSizeResidue));

        List<Row> kmerList = new ArrayList<Row>();
        int readLength;
        String[] units;
        String read;
        char nucleotide;
        long nucleotideInt;
        long nucleotideIntComplement;

        public Iterator<Row> call(Iterator<String> s){

            while (s.hasNext()) {
                units = s.next().split("\\n");
                read = units[1];
                readLength = read.length();


                if (readLength - param.kmerSize - param.endClip +1 <= 0 || param.frontClip > readLength) {
                    continue;
                }

                Long nucleotideBinary = 0L;
                Long nucleotideBinaryReverseComplement = 0L;
                long[] nucleotideBinarySlot = new long[param.kmerBinarySlots];
                long[] nucleotideBinaryReverseComplementSlot = new long[param.kmerBinarySlots];

                for (int i = param.frontClip; i < readLength - param.endClip; i++) {
                    nucleotide = read.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);

                    // forward kmer in bits
                    if (i - param.frontClip <= param.kmerSize-1) {
                        nucleotideBinary <<= 2;
                        nucleotideBinary |= nucleotideInt;

                        if ((i - param.frontClip+1) % 32 == 0) { // each 32 nucleotides fill a slot
                            nucleotideBinarySlot[(i - param.frontClip+1) / 32 - 1] = nucleotideBinary;
                            nucleotideBinary = 0L;
                        }

                        if (i - param.frontClip == param.kmerSize-1) { // start completing the first kmer
                            nucleotideBinary &= maxKmerBits;
                            nucleotideBinarySlot[(i - param.frontClip+1) / 32] = nucleotideBinary; // (i-param.frontClip+1)/32 == nucleotideBinarySlot.length -1
                            nucleotideBinary = 0L;

                            // reverse complement

                        }
                    }else{
                        // the last block, which is shorter than 32 mer
                        Long transitBit1 = nucleotideBinarySlot[param.kmerBinarySlots-1] >>> 2*(param.kmerSizeResidue-1) ;  // 0000**----------  -> 000000000000**
                        // for the next block
                        Long transitBit2; // for the next block

                        // update the last block of kmer binary array
                        nucleotideBinarySlot[param.kmerBinarySlots-1] <<= 2;    // 0000-------------  -> 00------------00
                        nucleotideBinarySlot[param.kmerBinarySlots-1] |= nucleotideInt;  // 00------------00  -> 00------------**
                        nucleotideBinarySlot[param.kmerBinarySlots-1] &= maxKmerBits; // 00------------**  -> 0000----------**

                        // the rest
                        for (int j = param.kmerBinarySlots-2; j >=0; j--) {
                            transitBit2 = nucleotideBinarySlot[j] >>> (2*31);   // **---------------  -> 0000000000000**
                            nucleotideBinarySlot[j] <<=2;    // ---------------  -> --------------00
                            nucleotideBinarySlot[j] |= transitBit1;  // -------------00 -> -------------**
                            transitBit1= transitBit2;
                        }
                    }

                    // reverse kmer binarizationalitivities :) non English native speaking people making fun of English
                    nucleotideIntComplement = nucleotideInt ^ 3;  // 3 is binary 11; complement: 11(T) to 00(A), 10(G) to 01(C)

                    if (i - param.frontClip <= param.kmerSize -1){
                        if (i-param.frontClip < param.kmerSizeResidue-1){
                            nucleotideIntComplement <<=2 * (i-param.frontClip);   //
                            nucleotideBinaryReverseComplement |= nucleotideIntComplement;
                        }else if (i-param.frontClip == param.kmerSizeResidue-1){
                            nucleotideIntComplement <<=2 * (i-param.frontClip);
                            nucleotideBinaryReverseComplement |= nucleotideIntComplement;
                            nucleotideBinaryReverseComplementSlot[param.kmerBinarySlots-1] = nucleotideBinaryReverseComplement; // param.kmerBinarySlot-1 = nucleotideBinaryReverseComplementSlot.length -1
                            nucleotideBinaryReverseComplement =0L;

                            /**
                             * param.kmerSizeResidue is the last block length;
                             * i-param.frontClip is the index of the nucleotide on the sequence;
                             * +1 change index to length
                             */
                        }else if ((i- param.frontClip-param.kmerSizeResidue +1) % 32 ==0){  //

                            nucleotideIntComplement <<= 2 * ((i - param.frontClip-param.kmerSizeResidue) % 32); // length (i- param.frontClip-param.kmerSizeResidue +1) -1 shift
                            nucleotideBinaryReverseComplement |= nucleotideIntComplement;

                            // filling the blocks in a reversed order
                            nucleotideBinaryReverseComplementSlot[param.kmerBinarySlots - ((i- param.frontClip-param.kmerSizeResidue +1)/32) -1]= nucleotideBinaryReverseComplement;
                            nucleotideBinaryReverseComplement=0L;
                        } else{
                            nucleotideIntComplement <<= 2 * ((i - param.frontClip-param.kmerSizeResidue) % 32); // length (i- param.frontClip-param.kmerSizeResidue +1) -1 shift
                            nucleotideBinaryReverseComplement |= nucleotideIntComplement;
                        }
                    }else {
                        // the first transition bit from the first block
                        long transitBit1 = nucleotideBinaryReverseComplementSlot[0] << 2*31;
                        long transitBit2;

                        nucleotideBinaryReverseComplementSlot[0] >>>= 2;
                        nucleotideIntComplement <<= 2*31;
                        nucleotideBinaryReverseComplementSlot[0] |= nucleotideIntComplement;

                        for (int j=1; j<param.kmerBinarySlots-1; j++){
                            transitBit2 = nucleotideBinaryReverseComplementSlot[j] << 2*31;
                            nucleotideBinaryReverseComplementSlot[j] >>>= 2;
                            // transitBit1 <<= 2*31;
                            nucleotideBinaryReverseComplementSlot[j] |= transitBit1;
                            transitBit1 = transitBit2;
                        }

                        nucleotideBinaryReverseComplementSlot[param.kmerBinarySlots-1] >>>= 2;
                        transitBit1 >>>= 2*(31-param.kmerSizeResidue+1);
                        nucleotideBinaryReverseComplementSlot[param.kmerBinarySlots-1] |= transitBit1;
                    }

                    /*
                    if (i - param.frontClip >= param.kmerSize) {
                        nucleotideBinaryReverseComplement >>>= 2;
                        nucleotideIntComplement <<= 2 * (param.kmerSize - 1);
                    } else {
                        nucleotideIntComplement <<= 2 * (i - param.frontClip);
                    }
                    nucleotideBinaryReverseComplement |= nucleotideIntComplement;
*/
                    // reach the first complete K-mer
                    if (i - param.frontClip >= param.kmerSize - 1) {




                        if (compareLongArrayBlocks(nucleotideBinarySlot, nucleotideBinaryReverseComplementSlot) == true) {
                            // System.out.println(nucleotideBinarySlot[0] + " forward " + nucleotideBinarySlot[1] + " rc " + nucleotideBinaryReverseComplementSlot[0]);

                            long[] nucleotideBinarySlotPreRow = new long[param.kmerBinarySlots];
                            for (int j=0; j<nucleotideBinarySlot.length; j++){
                                nucleotideBinarySlotPreRow[j] = nucleotideBinarySlot[j];
                            }
                            kmerList.add(RowFactory.create(nucleotideBinarySlotPreRow, 1));  // the number does not matter, as the count is based on units
                        } else {
                            //  System.out.println(nucleotideBinaryReverseComplementSlot[0] + " RC " + nucleotideBinaryReverseComplementSlot[1] + " forward " + nucleotideBinarySlot[0]);

                            long[] nucleotideBinaryReverseComplementSlotPreRow = new long[param.kmerBinarySlots];
                            for (int j=0; j<nucleotideBinarySlot.length; j++){
                                nucleotideBinaryReverseComplementSlotPreRow[j] = nucleotideBinaryReverseComplementSlot[j];
                            }
                            kmerList.add(RowFactory.create(nucleotideBinaryReverseComplementSlotPreRow, 1));
                        }
                    }
                }
            }

            return kmerList.iterator();
        }

        private boolean compareLongArrayBlocks(long[] forward, long[] reverse){
            for (int i=0; i<forward.length; i++){

                // binary comparison from left to right, because of signed long
                if (i<forward.length-1) {
                    for (int j = 0; j < 32; j++) {
                        long shiftedBinary1 = forward[i] >>> (2 * (31 - j));
                        shiftedBinary1 &= 3L;
                        long shiftedBinary2 = reverse[i] >>> (2 * (31 - j));
                        shiftedBinary2 &= 3L;

                        if (shiftedBinary1 < shiftedBinary2) {
                            return true;
                        } else if (shiftedBinary1 > shiftedBinary2) {
                            return false;
                        }
                    }
                }else{
                    for (int j = 0; j < param.kmerSizeResidue; j++) {
                        long shiftedBinary1 = forward[i] >>> (2 * (param.kmerSizeResidue -1 - j));
                        shiftedBinary1 &= 3L;
                        long shiftedBinary2 = reverse[i] >>> (2 * (param.kmerSizeResidue -1 - j));
                        shiftedBinary2 &= 3L;

                        if (shiftedBinary1 < shiftedBinary2) {
                            return true;
                        } else if (shiftedBinary1 > shiftedBinary2) {
                            return false;
                        }
                    }
                }
            }

            // should not happen
            return true;
        }

        // for testing, remove afterwards
        private char BinaryToNucleotide (Long twoBits){
            char nucleotide;
            if (twoBits == 0L){
                nucleotide = 'A';
            }else if (twoBits == 1L){
                nucleotide = 'C';
            }else if (twoBits == 2L){
                nucleotide = 'G';
            }else{
                nucleotide = 'T';
            }
            return nucleotide;
        }

        private long nucleotideValue(char a) {
            long value;
            if (a == 'A') {
                value = 0L;
            } else if (a == 'C') {
                value = 1L;
            } else if (a == 'G') {
                value = 2L;
            } else { // T
                value = 3L;
            }
            return value;
        }

        private boolean compareLongArray (Long[] a, Long[] b){

            return true;
        }

        private Long[] shiftLongArrayBinary (Long[] previousKmer){
            return previousKmer;
        }
    }


    class ReverseComplementKmerBinaryExtractionFromDataset implements MapPartitionsFunction<String, Long>, Serializable {
        long maxKmerBits = ~((~0L) << (2 * param.kmerSize));

        List<Long> kmerList = new ArrayList<Long>();
        int readLength;
        String[] units;
        String read;
        char nucleotide;
        long nucleotideInt;
        long nucleotideIntComplement;

        public Iterator<Long> call(Iterator<String> s) {

            while (s.hasNext()) {
                units = s.next().split("\\n");
                read = units[1];
                readLength = read.length();

                if (readLength - param.kmerSize - param.endClip <= 1 || param.frontClip > readLength) {
                    continue;
                }

                Long nucleotideBinary = 0L;
                Long nucleotideBinaryReverseComplement = 0L;

                for (int i = param.frontClip; i < readLength - param.endClip; i++) {
                    nucleotide = read.charAt(i);
                    if (nucleotide >= 256) nucleotide = 255;
                    nucleotideInt = nucleotideValue(nucleotide);
                    // forward kmer in bits
                    nucleotideBinary <<= 2;
                    nucleotideBinary |= nucleotideInt;
                    if (i - param.frontClip >= param.kmerSize) {
                        nucleotideBinary &= maxKmerBits;
                    }

                    // reverse kmer binarizationalitivities :) non English native speaking people making fun of English
                    nucleotideIntComplement = nucleotideInt ^ 3;  // 3 is binary 11; complement: 11(T) to 00(A), 10(G) to 01(C)

                    if (i - param.frontClip >= param.kmerSize) {
                        nucleotideBinaryReverseComplement >>>= 2;
                        nucleotideIntComplement <<= 2 * (param.kmerSize - 1);
                    } else {
                        nucleotideIntComplement <<= 2 * (i - param.frontClip);
                    }
                    nucleotideBinaryReverseComplement |= nucleotideIntComplement;

                    // reach the first complete K-mer
                    if (i - param.frontClip >= param.kmerSize - 1) {
                        if (nucleotideBinary.compareTo(nucleotideBinaryReverseComplement) < 0) {
                            kmerList.add(nucleotideBinary);
                        } else {
                            kmerList.add(nucleotideBinaryReverseComplement);
                        }
                    }
                }
            }
            return kmerList.iterator();
        }

        private long nucleotideValue(char a) {
            long value;
            if (a == 'A') {
                value = 0L;
            } else if (a == 'C') {
                value = 1L;
            } else if (a == 'G') {
                value = 2L;
            } else { // T
                value = 3L;
            }
            return value;
        }
    }

    /**
     * interface class for RDD implementation, used in step 3
     *      -----------
     *      ------
     *       ------
     *        ------
     *         ------
     *          ------
     *           ------
     */


    class DSFastqUnitFilter implements FilterFunction<String>, Serializable {
        public boolean call(String s) {
            return s != null;
        }
    }

    /**
     * interface class for RDD implementation, Used in step 1
     */


    class DSFastqFilterWithQual implements MapFunction<String, String>, Serializable {
        String line = "";
        int lineMark = 0;

        public String call(String s) {
            if (lineMark == 2) {
                lineMark++;
                line = line + "\n" + s;
                return null;
            } else if (lineMark == 3) {
                lineMark++;
                line = line + "\n" + s;
                return line;
            } else if (s.startsWith("@")) {
                line = s;
                lineMark = 1;
                return null;
            } else if (lineMark == 1) {
                line = line + "\n" + s;
                lineMark++;
                return null;
            } else {
                return null;
            }
        }
    }

    /**
     * interface class for RDD implementation, used in step 2
     */


    /**
     *
     * @param param
     */
    public void setParam(DefaultParam param) {
        this.param = param;
    }
}
